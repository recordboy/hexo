{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"자바스크립트 소개","text":"자바스크립트는 프로토타입 기반의 스크립트 언어이다. 주로 웹 브라우저 내에서 주로 사용되며 Node.js 와 같은 런타입 환경과 같이 서버 사이드 프로그래밍에도 사용되고 있다. 창시자는 넷스케이프사의 브렌던 아이크이다. 자바스크립트의 역사초창기 자바스크립트는 웹 페이지 제작에 있어서 보조적인 기능을 수행하기 위한 용도로써 사용되었다. 클라이언트인 웹 브라우저에서 서버로부터 받은 HTML과 CSS, 데이터로 렌더링을 해주는 수준이였다. 이 시절에 자바스크립트는 그다지 중요한 역할을 담당하지 못했다. 하지만 소수의 프로그래머들에 의해 여러 가지 연구가 이루어졌고, 웹 아키텍쳐에도 크고 작은 변화가 일어났다. 특히 과거에 서버에서 담당했던 역할들이 상당 부분 웹 브라우저로 이동하였고, 자바스크립트는 이 변화의 중점에 서게 된다. 게다가 jQuery 의 등장으로 보다 쉽게 DOM을 핸들링하게 되면서 많은 발전을 이루었다.현재는 브라우저 기반의 자바스크립트 라이브러리 뿐만 아니라 Node.js와 같은 서버 기반의 자바스크립트 환경에서 동작할 수 있는 각종 라이브러리까지 쏟아져 나오고 있다.이제는 자바스크립트만으로 웹 서버와 클라이언트인 웹 페이지 개발을 동시에 할 수 있는 수준까지 왔다고 볼 수 있다. 자바스크립트 언어의 특징자바스크립트는 클래스를 지원하지 않지만 객체지향 프로그래밍이 가능하다.여기서 객체 지향 프로그래밍(OOP)에 대해 잠깐 짚어본다. 객체 지향 프로그래밍(OOP)줄여서 OOP 라고 부르겠다. OOP는 컴퓨터 프로그래밍 패러다임중 하나이며, 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 “객체” 들의 모임으로 파악하고자 하는 것이다. 각각의 객체들은 메시지를 주고받고, 데이터를 처리할 수 있다. 객체지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용되고, 보수를 간편하게 하며 보다 직관적인 코드 분석을 가능하게 하는 장점을 가지고 있다. 객체지향의 반대로는 절차지향 프로그래밍(procedural Programming)이라는 패러다임이 있다. 절차지향 프로그래밍이란 순차적인 처리가 중요시되며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 대표적인 절차지향 언어에는 C언어가 있다. OOP의 특성으로는 추상화(Abstraction), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)이 있으며 이 개념은 추후에 알아보도록 하겠다.","link":"/2017/02/01/javascript-introduce/"},{"title":"자바스크립트 변수","text":"프로그래밍에서 기본이 되는 데이터를 담는 공간이다. 어떠한 값을 저장하기 위한 공간이면서 변할수 있다는 뜻을 가지고 있다. 변수의 반대말로는 변하지 않는 상수가 있다. 선언 방법은 var 라는 키워드를 사용한다. 1var 변수이름 = 저장데이터; = 는 대입 연산자로서 우측에 있는 값을 왼쪽에 있는 변수에 담는 연산자다. 세미콜론(;)은 문장의 끝을 알린다. 오류를 방지하기 위해 문장이 끝나면 꼭 선언해 주도록 하자 참고로 함수 선언식에서는 마지막에 세미콜론을 붙이지 않는데 이건 하나의 관습이고, 코드 작성시 권장되는 방식이다. 그리고 자바스크립트에서는 세미콜론 사용을 강제하지는 않는다. 그 이유는 자바스크립트 인터프리터가 자동으로 세미콜론을 삽입시켜 주기 때문이다. 하지만 세미콜론을 꼭 선언해 주는 습관을 가지도록 해야한다. 신경을 안쓴다면 코드를 압축하거나 디버깅 할시에 심각한 오류를 가지게 될수 있기 때문이다. 변수는 크게 네가지로 나뉠수 있으며 종류는 전역변수(Global Variable) : 전역에서 사용되는 변수로서 어디서든 접근이 가능하다. 지역변수(Local Variable) : 특정 지역에서 사용되는 변수로서 보통 함수 내부에 만들어 지는 변수 매개변수(Parameter) : 함수 외부에서 데이터를 받아 올때 사용되는 변수 속성(Property) : 객체의 속성값으로 쓰이는 변수이다. 참고로 전역 객체는 window 객체이다. 전역변수를 선언한다면 자동으로 window 객체의 프로퍼티가 된다고 생각하면 된다. 아래 코드를 참고 123var obj = { name: \"foo\" // name = 속성(프로퍼티, 아니면 키), foo = 속성의 값(프로퍼티 값 아니면 키값)}; 인자(Arguments)와 매개변수(Parameter)에 대해 많이 헷갈려 했었는데, 인자는 함수를 호출할때 대입하는 값을 의미하고 매개변수는 함수 내에 있는 값을 의미한다고 볼 수 있다. 1234function func(foo){ return foo; // foo = 매개변수}func(\"value\"); // \"value\" = 인자 변수를 만들때는 주의사항이 네가지 있다. 변수명은 대소문자를 구분해야 한다. 변수명은 소문자로 시작하고, 관례상 카멜기법을 사용한다. 여기서 카멜기법이란 문자모양이 낙타와 비슷하다고 해서 지어졌다. 네이밍 기법은 3가지로 분류할수 있다. 카멜기법(myName) 스네이크 기법(my_name) 파스칼 기법(my-name) 한번 저장하고 변하지 않는 상수값은 모두 대문자로 작성한다. 자바 언어 같은 경우 상수 값을 만드는 방법이 지원되지만 자바스크립트는 없다. 그래서 관례상 대문자로 작성하는 것이다. 예가 몇가지 있는데 슬라이드 플러그인에서 사용자가 정의하는 변수나 그누보드의 config.php 에 나와있는 상수 선언 등이 있다. 키워드(예약어)를 사용하면 안된다.(예: var, function, break 등등 아주 많음) 예약어로 변수를 선언하면 브라우저에서 오류 메세지가 출력되므로 많은 예약어를 따로 외울 필요는 없다.","link":"/2017/05/02/javascript-variable/"},{"title":"자료형(원시 타입)","text":"자료형은 데이터 값의 유형이다.원시타입과 객체(참조)타입으로 나눌 수 있는데 원시타입으로는 문자열(String), 숫자(Number), 논리형(Boolean), 언디파인드(Undefined), 널(Null) 값이 있다. 객체(참조)타입으로는 객체(Object), 배열(Array), 함수(Function)가 있다. 여기서 객체(참조)타입과 객체(Object)의 차이에 대해 혼동하기 쉽다. 객체(참조)타입은 기본타입을 제외한 모든 자바스크립트의 객체를 가르키며, 객체(Object), 배열(Array), 함수(Function)도 객체(참조)타입 에 포함된다. 객체(Object)는 자바스크립트에서 표현되는 자료형의 값이며 객체(참조)타입중에 하나인 객체(Object)이다. 기본타입문자(String)우리가 실생활에서 쓰고 있는 글자를 문자열이라고 생각하면 된다. 변수에 담는 방식은 큰따옴표나 작은 따옴표로 감싸서 저장하시면 된다. 문자열에 따옴표를 포함하고 싶으면 다른 따옴표로 감싸주면 된다. 12var str = 'data'; // 문자열을 담을 때var str = \"'data'\"; // 작은 따옴표를 문자열에 추가하고 싶을때 참고로 따옴표를 문자열로 인식하고 싶을때는 역슬래쉬를 따옴표 앞에 붙여 사용하면 된다. 이 작업을 이스케이핑이라고 부른다. 1var str = \"'data'\"; // 작은 따옴표를 문자열로 인식하고 싶을때 숫자(Number)우리가 알고있는 숫자라고 생각하면 된다. 자바스크립트는 모든 숫자를 64비트 부동소숫점 형태로 저장하기 때문에 하나의 타입만 존재하며 형태는 크게 정수형(10진수, 16진수), 실수형으로 나뉜다. 정수형(10진수) : 평상시에 사용하는 10진수이며, 소숫점이 없다. 정수형(16진수) : Ox로 시작하며 숫자 09와 문자 AF를 사용해서 숫자를 표현한다. 보통 색상을 나타낼때 사용한다.(예 : 0xF00) 실수형 : 소숫점을 갖는 숫자 자바스크립트는 소숫점을 계산할때 한가지 오류가 있는데 확인하고 넘어가자하단의 코드를 보면 1console.log(0.1 + 0.2); 결과는 0.3 이 나올겉 같지만 0.30000000000000004 가 출력이 된다. 이것이 부동소수점 오류며 아래와 같은 방법으로 해결을 할 수 있다. 주의하도록 하자. 1console.log(((0.1*10)+(0.2*10))/10); 논리형(Boolean)쉽게 설명해서 참, 거짓이라고 생각하면 된다. 참 : true 거짓 : false 데이터 타입마다 true, false로 변환되는 값이 다르다. 데이터 타입 true로 변환되는 값 false로 변환되는 값 불리언 true flase 문자열 비어 있지 않은 모든 문자열 “”(빈 문자열) 숫자 0이 아닌 모든 숫자(무한대 포함) 0, NaN 객체 모든 객체 null Undefined 해당 없음 undefined 널(Null)널은 아무것도 참조하고 있지 않다라는 의미이다. 여기서 언디파인드와 널이 많이 헷갈릴 수가 있다. 언디파인드는 값 자체가 선언이 되지 않은거고 널은 임의로 빈 값으로 선언한 상태라고 보면 된다. 널은 객체를 담을 변수를 초기화할때 많이 사용한다. 1234var num = 0; // 숫자 초기화var str = ''; // 문자 초기화var boolean = false; // 논리형 초기화var obj = null; // 객체 초기화","link":"/2017/05/03/javascript-primitive-data-type/"},{"title":"자료형(참조 타입)","text":"이전 포스팅에서도 언급했지만 참조타입으로는 객체(Object), 배열(Array), 함수(Function)가 있다. 원시타입과 참조타입을 비교하는것에 초점을 두어 간단히 알아본다. 객체(Object)자바스크립트에서 객체는 단순하게 표현하면 속성명(Key), 값(value) 형태의 속성(property)을 저장하는 그릇이라고 생각하면 된다. 즉 여러 값을 표현하는 묶음을 만들때 사용된다. 간단한 객체를 만들어 보겠다. 1234var person = { name: '철수', age: '20'}; 속성명은 name, age 값은 ‘철수’, ‘20’인 객체를 선언했다. 객체 선언 방식은 {}(중괄호)로 한다. 이 선언 방식은 객체 리터널 방식이라고 하며, 리터널이란 용어의 의미는 표기법이라고 생각하면 된다. 리터널 방식은 간단한 표기법만으로도 객체룰 생성할 수 있는 자바스크립트의 강력한 문법이다. 객체의 프로퍼티에 접근하려면 마침표 표기법과 대괄호 표기법이 있다. 1console.log(person.name); // 철수 배열(Array)배열은 변수에 여러가지의 값을 한번에 담을 수 있는 그릇이라고 볼 수 있다. 위에 언급한 객체와 비슷해 보일 수 있지만 배열의 속성명은 각 프로퍼티의 인덱스 값이다. 선언방식은 [](대괄호)로 하고 객체와 마찬가지로 이는 배열 리터널이다. 1var person = ['철수', '20']; 객체와는 다르게 배열의 속성명은 인덱스 값이라고 했다. 그러므로 person의 첫번째 값인 ‘철수’의 속성명(Key)은 배열의 첫번째 인덱스인 0이고, 두번째 값(value)인 ‘20’의 속성명은 1이 되는 것이다. 배열의 프로퍼티에 접근하려면 대괄포 표기법을 이용하면 된다. 12console.log(person[0]); // 철수 console.log(person[1]); // 20 함수(Function)함수는 특정 기능을 하는 구문(알고리즘, 로직)을 독립된 부품으로 만들어 재사용하고자 할때 사용하는 문법이다. 함수를 선언할때는 function키워드를 사용하며 구조는 아래에서 확인할 수 있다. 1234function 함수이름(파라미터){ // 알고리즘 return 값 // 리턴 값} 객체(참조)타입이 무엇이 있나 간단히 봤다. 원시타입과 객체(참조)타입의 차이점을 알아보도록 하자 원시 타입과 참조 타입의 차이자바스크립트에서는 원시타입인 숫자, 문자열, 논리형, 널, 언디파인드 다섯가지를 제외한 모든 값은 객체(참조)타입 이다. 참조 타입이라고 불리는 이유는 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문이다. 아래 예제를 살펴 보자 12345var num1 = 10, num2 = num1;console.log(num2); // 10 num1 = 20;console.log(num2); // 10 원시타입은 값 자체를 비교한다.변수 num1에다가 10을 대입하고 num1를 num2에 대입했다. 변수에 할당된 값 자체를 복사하였기 때문에 num2의 값은 10이다. num2에 20을 대입해도 num2의 값은 변하지 않는다. num2에 직접적으로 값을 대입하지 않았기 때문이다.아래 참조타입을 보자 1234567var obj1 = { val: 10};var obj2 = obj1;console.log(obj2.val); // 10obj1.val = 20;console.log(obj2.val); // 20 우선 obj1에 객체 리터널을 선언하고, val 프로퍼티에 10을 담았다. 그리고 obj2에 obj1을 할당했다. obj2의 val프로퍼티의 값은 10이 출력된다. 여기서 obj1의 val에 20을 담았다. obj2의 val값을 건들지도 않았는데 obj1 처럼 val값이 20으로 봐뀌어있다. 어떻게 된 것일까? 값 자체가 복사되는 원시값과는 달리 참조타입은 참조(객체를 가르키는 참조값 혹은 메모리 주소)만 복사되고 실제 값은 복사되지 않는다. 즉 obj1과 obj2는 실제 데이터를 가지고 있는 객체의 주소값만 가지고 있는 것이다.","link":"/2017/05/05/javascript-reference-data-type/"},{"title":"GET과 POST 차이","text":"HTTP 웹상에서 클라이언트와 서버 간에 데이터를 주고 받을 수 있는 프로토콜 HTTP 메소드에는 2가지 방식이 있는데, 그것이 GET 방식과 POST 방식 GETURL에 파라미터를 포함시켜 요청하는 방식이다. 예를들어 https://recordboy.github.io/login?id=user&amp;pw=1234 라는 페이지가 있다고 치자, ? 마크를 통해 URL의 끝을 알리고, id라는 키(key)에 대해선 user라는 값(value)를, pw라는 키(key)에 대해서는 1234라는 값(value)을 전송한 것을 볼 수 있다. 여러개의 키와 값을 보낼 때는 &amp;를 사용하여 이어준다. 이처럼 데이터가 노출되기 때문에 보안에 취약하며, 개인정보가 포함되지 않는 상황에서 캐싱을 하여 페이지 로딩 속도를 높일 때 사용된다. 특징 URL에 파라미터를 포함시켜 요청한다. 데이터를 Header(헤더)에 포함하여 전송한다. URL에 파라미터가 노출되어 보안에 취약하다. 캐싱할 수 있다. GET 방식은 글자수 제한이 있지만, 256자 라는 말은 사실이 아니다. 익스 9의 경우 2083자/최대 5120자를 지원사파리는 40만자를 넘기면 브라우저가 크러쉬파이어폭스/오페라는 길이 제한이 없고 50만자를 넘겨도 별다른 이상 없음크롬의 경우 4만자를 기준 POSTPOST는 제출하다라는 뜻으로 BODY에 데이터를 넣어 전송하며 길이의 제한이 없다. 따라서 GET과 다르게 대용량 데이터를 전송할 수 있으며, BODY에 전송되어 내용이 눈에 보이지 않아 보안적으로 안전하다고 할 수 있다. 하지만 POST요청도 크롬 개발자 도구같은 툴로 요청내용을 확인할 수 있기 때문에 민감한 데이터는 반드시 암호화 하여 전달해야 한다.그리고 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 명시해야 한다. 종류는 여러가지가 있지만 몇가지 나열해보면 application/x-www-form-urlencoded GET방식과 마찬가지로 BODY에 key와 value쌍으로 데이터를 넣는다. 똑같이 구분자 &amp;를 쓴다. text/plain BODY에 단순 텍스트를 넣는다. multipart/form-data 파일전송을 할때 많이 쓰는데 BODY의 데이터를 바이너리 데이터로 넣는다는걸 알려준다. 특징 BODY에 데이터를 넣어 전송하며 길이의 제한이 없어 대용량 데이터를 전송할 수 있다. BODY에 데이터가 들어가기 때문에 GET보다는 보안상 유리하지만 민감한 데이터는 꼭 암호화를 해줘야 한다. 요청 헤더의 Content-Type에 요청 데이터의 타입을 명시해야 한다. References GET과 POST의 차이[Web] GET과 POST의 비교 및 차이get 방식의 글자 256자 제한은 잘못된 상식GET방식 과 POST방식","link":"/2017/12/04/get-post/"},{"title":"자바스크립트 반올림, 올림, 내림","text":"반올림Math.round(); 12var num = 3.5;console.log(Math.round(num)); // 4 올림Math.ceil(); 12var num = 3.5;console.log(Math.ceil(num)); // 4 내림Math.floor(); 12var num = 3.5;console.log(Math.floor(num)); // 3","link":"/2017/11/01/javascript-math-round/"},{"title":"자바스크립트 eval() 함수","text":"eval() eval()은 전역 객체(window)의 함수 속성이다. eval()의 인자는 문자열이며 문자열 형태를 연산할 수 있다. 12345console.log('2 + 2');// 2 + 2console.log(eval('2 + 2'));// 4 eval() 문제점 굳이 eval() 함수를 쓰지 않아도 충분히 동일한 동작을 구현할 수 있는 경우가 많다. 보안상 위험한 javascript 코드를 실행할 수 있다는 위험때문에 eval() 함수는 권장되지 않는다. References eval()eval() 사용과 문제점 : #eval() is evilJavaScript eval 함수","link":"/2017/12/01/javascript-mehod-eval/"},{"title":"스코프(Scope)","text":"자바스크립트에서의 스코프란 코드가 실행되는 컨텍스트(유효범위)이며 전역 스코프, 지역 스코프, eval 스코프로 나눌 수 있다. 전역 스코프 함수나 객체의 밖에서 선언되었다면 전역 스코프로 정의된다. 모든 곳에서 전역 스코프에 있는 변수를 사용할 수 있다. 12345678// 전역 스코프var foo = 1;console.log(foo); // 1function func() { // foo가 전역에서 선언되었기 때문에 함수 내부에서도 foo값을 사용할 수 있다. console.log(foo); // 1} 지역 스코프 함수나 객체의 안에서 선언되었다면 지역 스코프로 정의된다. 해당 함수나 객체에서만 지역 스코프를 사용할 수 있다. 함수 지역 스코프123456789function func() { // 지역 스코프 var foo = 1; console.log(foo); // 1}// foo가 func 함수 내부에서 선언되었기 때문에 함수 외부에서 사용을 할 수 없다.console.log(foo); // Uncaught ReferenceError: foo is not defined 객체 지역 스코프12345var obj = { foo: 1};console.log(obj.boo); // 1console.log(boo); // Uncaught ReferenceError: foo is not defined eval 스코프 eval의 경우 eval()을 사용해 매개변수를 사용하면 이를 사용했을 경우에만 해당 스코프에 담긴 값을 불러온다. 각각 선언할때 고유한 스코프를 가지는 것이 특징이다.","link":"/2017/12/02/javascript-scope/"},{"title":"자바스크립트 노드 생성 및 추가","text":"노드 생성 1var input = document.createElement('input'); 생성된 노드 속성 추가 1input.setAttribute('type', 'text'); 텍스트 노드 추가 1var txt = document.createTextNode('hello'); 부모 노드에 생성된 노드 추가 1부모노드.appendChild(input); 테이블 생성 예제위 노드 추가 방법으로 테이블 추가 예제를 만들어 보자, 버튼을 계속 클릭하면 테이블이 추가된다. 1234&lt;div class=\"wrap\"&gt; &lt;button id=\"btn\"&gt;click&lt;/button&gt; &lt;table id=\"tbl\"&gt;&lt;/table&gt;&lt;/div&gt; 1234567891011121314151617181920212223.wrap { position: relative; padding-top: 40px;}.wrap * { margin: 0; padding: 0}#tbl td { border: 1px solid #ccc; padding: 3px 10px; text-align: center;}#btn { position: absolute; top: 0; left: 0; width: 50px; height: 30px;} 1234567891011121314151617181920212223242526272829303132333435window.onload = function () { // 노드 선언 var btn = document.getElementById('btn'), tbl = document.getElementById('tbl'), tblTr = tbl.getElementsByTagName('tr'); // 버튼 이벤트 btn.addEventListener('click', function () { tblAdd(); }); // 테이블 추가 function tblAdd() { var tr = document.createElement('tr'); for (var i = 0; i &lt; 5; i++) { var td = document.createElement('td'); tr.appendChild(td) }; tbl.appendChild(tr); numAdd(); } // 테이블 번호 추가 function numAdd() { var num = 0; for (var i = 0; i &lt; tblTr.length; i++) { for (var j = 0; j &lt; tblTr[i].getElementsByTagName('td').length; j++) { num++; tblTr[i].getElementsByTagName('td')[j % 5].innerHTML = num; }; }; }} 구현 .wrap { position: relative; padding-top: 40px; } .wrap * { margin: 0; padding: 0 } #tbl td { border: 1px solid #ccc; padding: 3px 10px; text-align: center; } #btn { position: absolute; top: 0; left: 0; width: 50px; height: 30px; } window.onload = function () { // 노드 선언 var btn = document.getElementById('btn'), tbl = document.getElementById('tbl'), tblTr = tbl.getElementsByTagName('tr'); // 버튼 이벤트 btn.addEventListener('click', function () { tblAdd(); }); // 테이블 추가 function tblAdd() { var tr = document.createElement('tr'); for (var i = 0; i < 5; i++) { var td = document.createElement('td'); tr.appendChild(td) }; tbl.appendChild(tr); numAdd(); } // 테이블 번호 추가 function numAdd() { var num = 0; for (var i = 0; i < tblTr.length; i++) { for (var j = 0; j < tblTr[i].getElementsByTagName('td').length; j++) { num++; tblTr[i].getElementsByTagName('td')[j % 5].innerHTML = num; }; }; } } click References HTML DOM appendChild() Method","link":"/2017/12/12/javascript-append-child/"},{"title":"날짜 구하기(Data 함수)","text":"DataData 객체는 날짜와 시간을 제공하는 생성자 함수이다.인자 없이 객체를 선언하면 현재 날짜와 시간을 반환한다. 123var value = new Date();console.log(value);// Thu Jan 09 2020 14:44:13 GMT+0900 (한국 표준시) 특정 값을 구하는 메서드 메서드 값 getFullYear() 년 getMonth() 월 getDate() 날짜 getDay() 요일 응용2015년 12월 25일의 요일을 구하는 법 1234function func(a, b) { return ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'][new Date(2015, a - 1, b).getDay()];}console.log(func(12, 25)); // FRI References 프로그래머스 문제 풀이 Level 1","link":"/2017/12/13/javascript-date/"},{"title":"문자열 자르기","text":"split()특정 문자열을 기준으로 잘라 배열로 반환한다. 123var str = '가, 나, 다, 라, 마'console.log(str.split(','));// (5) [\"가\", \" 나\", \" 다\", \" 라\", \" 마\"] substring(시작인덱스, 종료인덱스)시작인덱스를 기준으로 종료인덱스 까지 자른다. 123var str = '가나다라마'console.log(str.substring(1, 4));// 나다라 substring(시작인덱스, 길이)시작인덱스를 기준으로 문자열 길이로 자른다. 123var str = '가나다라마'console.log(str.substr(2, 2));// 다라","link":"/2017/12/04/javascript-truncate-string/"},{"title":"배수 구하기","text":"0부터 100까지 특정 배수를 구하는법이다.반복문과 조건문, 나머지 연산자가 사용된다. 123for(var i = 0;i &lt;= 100;i++){ console.log(i);}; i가 증감되면서 콘솔창에 1부터 100까지 차례로 출력될 것이다. 그렇다면 아래의 코드는 어떻게 출력될까? 123for(var i = 0;i &lt;= 100;i++){ console.log(i % 3);}; 12345670 1 2 0 1 2 . . . 0부터 2는 3으로 나눠지지 않기때문에 첫번째 피연산자가 출력되고 3은 나눠지기 때문에 0이 출력된다. 그 이후로는 3으로 나눈 뒤 나머지가 출력되기 때문에 위처럼 0, 1, 2, 0, 1, 2 .. 로 출력된다. i값이 3으로 나머지 없이 나눠지면 0이 출력되는걸 확인할 수 있다. 이걸 통해 조건문으로 3의 배수를 구할 수 있는 것이다. 12345for(var i = 0;i &lt;= 100;i++){ if(i % 3 === 0){ console.log(i); };}; 나머지 없이 3으로 나눠 질때만 i값이 출력된다. 하지만 i값이 0일 때도 같이 출력된다. 다중 조건문을 추가해 주자 12345for(var i = 0;i &lt;= 100;i++){ if(i % 3 == 0 &amp;&amp; i !== 0){ console.log(i); };}; 3의 배수가 원활하게 출력되는걸 확인할 수 있다.","link":"/2017/12/14/algorithm-multiple/"},{"title":"증가 감소","text":"슬라이드 배너 코드를 작성할 때 이전 슬라이드, 다음 슬라이드 인덱스 값이 필요할 경우 쓰이는 방법이다. 슬라이드 갯수와 다음, 이전 인덱스 값을 초기 설정해준다. 123var slideLength = 4, next = 0, prev = 0; 알고리즘이 들어갈 함수와 이벤트를 실행시킬 이벤트 리스너가 필요할 것이다.slide 함수를 선언하고 setInterval 함수에다가 이벤트 리스너를 등록하자 1234function slide(){ console.log(0);}setInterval(slide, 1000); 1초마다 콘솔창에 0이 출력된다. 이제 1초마다 다음 인덱스에 1을 더하며 그 값을 이전 인덱스에 주자 123456function slide(){ next++; console.log(next, prev); prev = next;}setInterval(slide, 1000); 콘솔창이 들어가있는 곳이 추후에 인덱스 다음과 이전 인덱스 값을 받아 처리하는 기능이 들어간다. 콘솔창을 보면 아래와 같이 다음과 이전이 1씩 밀리면서 출력된다. 123456781 0 2 1 3 2 4 3 5 4 6 5 7 6 . . . 하지만 슬라이드 갯수는 4개다. 다음 인덱스가 4 이상이 되면 0으로 초기화되도록 조건문을 입력하면 된다. 123456789function slide(){ next++; if(next &gt;= slideLength){ next = 0; }; console.log(next, prev); prev = next;}setInterval(slide, 1000); 아래와 같이 순차적으로 1씩 밀려서 출력되며, 4 이상이 되면 0으로 초기화가 된다. 123456781 0 2 1 3 2 0 3 1 0 2 1 3 2 . . . 이제 인덱스가 순차적으로 감소되는 코드를 작성해 보자 123456789function slide(){ next--; if(next &lt; 0){ next = slideLength - 1; }; console.log(next, prev); prev = next;}setInterval(slide, 1000); 다음 인덱스를 1식 빼고, 다음 인덱스가 0보다 작이질 시 슬라이드 갯수의 1을 뺀 값을 대입하면 된다. 1을 빼는 이유는 프래그래밍에서 수의 시작은 0부터 시작하기 때문이다. 네번째 슬라이드의 인덱스는 3이 될 것이다.","link":"/2017/12/15/algorithm-up-down/"},{"title":"자바스크립트 호출 스택(Call Stack)","text":"호출 스택호출 스택이란 함수의 호출을 기록하는 자료구조이다. 기본적으로 우리가 프로그램 안에서 위치한 곳이며, 만약 우리가 어떤 함수를 실행시킨다면, 우리는 스택 위에 무언가를 올리는(push) 행위를 하는 것이다. 그리고 우리가 함수로부터 반환을 받을 때, 우리는 스택의 맨 위를 가져오는(pop) 것이다. 자료구조란 사전적인 의미는 자료(Data)의 집합의 의미하며, 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것 123456789101112131415function func01() { throw new Error('Oops!');}function func02() { func01();}function func03() { func02();}func03();// Uncaught Error: Oops!// at func01 (index.html:27)// at func02 (index.html:30)// at func03 (index.html:33)// at window.onload (index.html:35) 위 코드를 실행해보면 콘솔창에 빨간 애러 스택들이 나온다. 보통 그것들은 호출 스택의 현재 상태를 나타내며, 실패함 함수를 스택처럼 위에서 아래로 나타낸다. 스택 오버플로우스택의 사이즈를 초과했을 때 발생하는 오류인데 보통 재귀를 호출했을 때 나타난다. 123456789101112131415function func() { func();}func();// Uncaught RangeError: Maximum call stack size exceeded// at foo (index.html:25)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26) 엔진에서 이 코드를 실행할 때, func()에 의해서 func 함수가 호출된다. 여기서 다시 func 함수를 호출하고 반복적으로 함수를 호출하게 된다. 그러면 매번 실행할 때마다 호출스택에 func() 가 쌓이며 최대 허용치를 넘으면 위처럼 에러를 발생시킨다. References Understanding Javascript Function Executions — Call Stack, Event Loop , Tasks &amp; more자바스크립트 개발자라면 알아야 할 33가지 개념 #1 콜스택 (번역)자료구조 : 자료구조란? (Data Structure)자바스크립트의 동작원리: 엔진, 런타임, 호출 스택","link":"/2018/02/01/javascript-call-stack/"},{"title":"중첩 반복문(별찍기)","text":"중첩 반복문의 별찍기 예제이다. 알고리즘 기초 문제로 자주 등장하는 예제중 하나이다.우선 하단의 별모양으로 찍어보자 12345678910******************************************************* 나는 프로그래밍을 처음 배울때 아래처럼 코드를 작성했었다. 12345var star = '';for(var i = 0;i &lt; 10;i++){ star += '*'; console.log(star);}; *이 저장될 star를 선언한뒤 하나씩 *을 한번씩 추가한뒤 반복문이 끝나지 않고 바로 콘솔창으로 출력이 된다. 콘솔창에 10번 출력되면 되는줄 알고 왜 반복문을 중첩으로 사용해야 되지? 라는 짧은(?) 생각을 했었던 적이 있었다.반복문이 돌아갈때마다 출력이 되는것이 아닌, 구해진 값을 담아 한번에 출력해야 한다. 이렬려면 반복문이 중첩으로 사용되어야 된다. 12345678var star = '';for(var i = 0;i &lt; 10;i++){ for(var j = 0;j &lt;= i;j++){ star += '*'; }; star += '\\n';};console.log(star); 코드를 차근히 살펴 보자 외부 반복문에서 i값이 0인 상태로 내부 반복문으로 들어 간다. j가 0으로 선언되고 j와 i를 비교한다. j와 i값은 0과 0으로 같기 때문에 star에 *이 한번 대입되고 내부 반복문을 빠져 나온뒤 줄바꿈문자인 \\n을 star에 대입시킨다. 외부 반복문이 다시 실행된다. i값이 +1 되어 1인 상태에서 다시 내부함수로 들어간다. 내부반복문의 조건은 j값이 i보다 같거나 클때 실행이 된다. j값은 0으로 초기화되었기 때문에 i값이 1이므로 star에 *을 두번 대입하고 내부반복문을 빠져나오게 되고 다시 \\n을 대입하여 줄바꿈이 이루어진다. 이 과정을 반복하여 열번째 *을 대입하고 마지막으로 결과값을 콘솔창에 뿌리게 된다.콘솔창을 보면 제대로 출력된 결과물을 볼 수 있다. 여기서 응용을 하여 아래 모양으로 출력해 보자 12345************************* 별이 2개씩 추가되었다. 외부반복문의 i값이 0일때 별을 한번 찍고, 이후에는 j값이 2의 배수 일때만 내부 반복문을 실행하는 조건을 달아주면 된다. 12345678var star = '';for(var i = 0;i &lt; 10;i++){ for(var j = 0;j &lt;= (i * 2);j++){ star += '*'; }; star += '\\n';};console.log(star); 정상적으로 출력되는걸 확인할 수 있다.아래처럼 역삼각형으로 나타낼려면 어떻게 할까? 1234567891011****************************************************************** 12345678var star = '';for(var i = 10;i &gt;= 0;i--){ for(var j = 0;j &lt;= i;j++){ star += '*'; }; star += '\\n';};console.log(star); i값을 10으로 설정한 뒤 i값이 0과 같아질때까지 i값을 빼주면 된다.정상적으로 코드가 출력되는걸 확인할 수 있다. 가운데 정렬 삼각형을 만들어 보자 12345 * *** ***** **************** 5줄로 만들어진 삼각형 이다. 차근차근 살펴 보자왼쪽부터 공백이 들어가고 별은 처음 한번 찍힌 뒤 2개씩 늘어나면서 찍힌다.이제 코드를 확인해 보자 1234567891011var star = '';for(var i = 0;i &lt; 5;i++){ for(var j = 4;j &gt; i;j--){ star += ' '; }; for(var k = 0;k &lt;= (i * 2);k++){ star += '*'; }; star += '\\n';};console.log(star); 별과 공백이 대입될 star를 선언한 뒤 외부 반복문이 실행된다. 5줄인 삼각형을 만들계획이니 외부 반복문은 5번만 실행해야 된다. i값이 5보다 작을때까지만 조건을 달아주고 내부 반복문으로 들어가고, 공백이 들어갈 반복문이 첫번째로 나온다. 5줄인 삼각형이니 공백은 4칸 대입 다음에 별이 한개 대입되고, 다음에는 공백 3칸에 별 세개, 이런식으로 반복되서 마지막 5줄째에는 공백이 없고 별만 9개가 대입되도록 짜면 될 것이다. 첫번째 내부 반복문에서 공백을 star에 4번 대입하고 빠져 나온다. 두번째 내부 반복문에서는 처음 별 한개를 대입한 뒤 이후에는 2의 배수만큼 별을 대입한다. 두번째 내부 반복문을 빠져나오면 줄바꿈이 대입되고, 외부 반복문이 다섯번 반복되면 이제 콘솔창에 결과값을 출력하게 된다. 이제 위에 예제를 응용하여 다이아몬드 형태를 만들어 보도록 하자복잡한 예제인 만큼 차근차근 해석해 나가도록 하자 123456789 * *** ***** **************** ******* ***** *** * 몇줄인지 보자.. 아홉줄이다. 9번 실행되는 반복문을 먼저 선언해 주자 1234var star = '';for(var i = 0;i &lt; 9;i++){}; 별이 다섯번째 줄까지 증가하다가 그 다음부터는 감소한다. i값이 4가 될 때까지만 별을 증가시켜 주는 조건문을 달고 내부 반복문을 선언해 주자 12345678910111213var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; };};console.log(star); 12345 * *** ***** **************** 위처럼 제대로 출력된다. 이전 예제에서 해봤기 때문에 어렵지 않게 작성할 수 있다.이제 i값이 5가되면 별이 감소하는 반복문을 추가한다. 공백을 먼저 넣을 것이다. 눈으로 확인하기 쉽게 우선 공백을 - 로 표기하겠다. 123456789101112131415161718var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += '-' }; star += '\\n'; };};console.log(star); i값이 4까지만 첫번째 조건문이 실행되고 i값이 5부터는 아래 조건문이 실행된다. 2번째 조건문 반복문을 만나서 j와 i값을 비교한다. j는 4로 선언되고 i는 5 이다. j는 i보다 작다. 참이다. 공백이 한번 찍히고 다시 돌면서 비교를 한다. j는 i와 같은 값인 5가 된다. 거짓이다. 반복문을 빠져나오고 줄바꿈을 한뒤 다시 외부 반복문이 i값을 증감 한다. 이 과정을 반복하면서 아래 모양처럼 출력된다. 123456789 * *** ***** ****************---------- 이제 - 을 공백처리 한 후 별을 찍는 반복문을 추가 해 보자 123456789101112131415161718192021var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += ' ' }; for(var k = 9;k &gt; i;k--){ star += '*' }; star += '\\n'; };};console.log(star); 여기서 좀 복잡해진다. 우선 별 반쪽만 찍어보도록 해보자 123456789 * *** ***** **************** **** *** ** * 아래 조건의 반복문은 i가 5부터 8까지만 4번 실행된다.i값이 5일때 k값과 비교를 한다. k는 9죠? 참이다. 별을 한번 찍고 k값은 차례로 내려간다. k 값이 9,8,7,6이 될때까지 별을 네번 찍고 반복문을 빠져 나온다.이 과정을 거쳐 위 모양처럼 별이 출력된다. 하지만 별은 2개씩 찍혀야 된다. 조건문에 2를 곱해보자 123456789101112131415161718192021var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += ' ' }; for(var k = 9;k &gt; i * 2;k--){ star += '*' }; star += '\\n'; };};console.log(star); 12345 * *** ***** **************** 공백만 나오고 안나온다.이유는 i값이 배가 되어 k값보다 훨 씬 커지기 때문이다. 처음 비교할때 k값은 9인데 i값은 10이기 때문이다. i값의 최대치는 8인데 배가 되니 16보다 큰 수가 k값으로 대입되어야 한다. 17을 대입해 주자 123456789101112131415161718192021var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += ' ' }; for(var k = 17;k &gt; i * 2;k--){ star += '*' }; star += '\\n'; };};console.log(star); k값은 17, i는 5 * 2 = 10 이다. 참이다. 별을 한번 찍고, 다시 비교, 16 &gt; 10 이다. 이과정을 네번 반복하고 계속 찍어 내려간다. 마지막 i값이 8일때 k는 17 i는 8*2 = 16 참이다. 다시 돌아서 k–은 16 이다. 16 &lt; 16 거짓이다. 반복문을 빠져 나온다. 제대로 출력되는 것을 확인할 수 있다.","link":"/2018/02/21/algorithm-star/"},{"title":"재귀 함수(Recursive Function)","text":"재귀(Recursive)를 정의한다면 한 함수가 자기 자신을 호출하는 순간이다. 재귀함수를 이해하기 전에는 팩토리얼 이라는 개념이 필요하다. 팩토리얼이란 자기 자신의 수에 1 작은 수를 곱하고 또 1 작은 수를 곱하고 해서 1 작은 수가 1이 될때까지 곱하는 것이다. 팩토리얼의 기호는 !이며 아래의 예제는 5!의 팩토리얼을 나타내고 있다. 15 * 4 * 3 * 2 * 1 = 120 이제 팩토리얼의 개념을 알았으니 재귀함수가 무엇인지 확인해 본다. 1234567function factorial(x) { if (x &lt; 0) return; if (x === 0) return 1; return x * factorial(x - 1);}factorial(3);// 6 결과 값이 나오는 과정을 순서대로 살펴보겠다. factorial 함수에 인자값으로 3을 담아 함수를 실행한다. 파라미터로 3을 받아 처음 조건문을 거친다. 3은 0보다 크기 때문에 다음 조건문으로 이동한다. 3은 0이 아니기 때문에 아래 구문으로 넘어간다. 3에 factorial 함수에 2를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 2를 넣어 실행한다. 2는 0보다 크고 0이 아니니 다시 아래 구문으로 내려간다. 2에 factorial 함수에 1를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 1를 넣어 실행한다. 1역시 0보다 크고 0이 아니니 다시 아래 구문으로 내려간다. 1에 factorial 함수에 0를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 0를 넣어 실행한다. 위와는 다르게 0은 두번째 조건문에서 걸려 1을 리턴한다. 결국은 3 * 2 * 1라는 값을 리턴하게 되는 것이다. 이렇게 함수가 자기 자신을 호출하는 순간을 재귀 라고 한다. References 재귀 함수자바스크립트 개발자라면 알아야 할 33가지 개념 #23 자바스크립트 : 자바스크립트 재귀(Recursion) 이해하기","link":"/2017/12/16/javascript-recursive/"},{"title":"switch 조건문","text":"switch키워드 오른쪽 ()안의 값과 case키워드 오른쪽의 값을 비교하여 true일시 콜론 오른쪽 구문을 실행하게 된다. 12345678var a = 0;switch (1) { case 1: console.log('ok'); break; case 2: console.log('no'); break;}// ok 조건을 만족시 구문을 실행하고, break키워드를 만나면 로직을 빠져나가게 된다. break키워드가 없을 경우 로직을 벗어나지 않고 계속 아래 조건을 읽어내려간다. 123456switch (1) { case 1: console.log('ok'); case 1: console.log('no');}// ok// no","link":"/2018/01/01/javascript-switch/"},{"title":"구구단 출력하기","text":"자바스크립트로 중첩 반복문을 활용한 구구단 출력하기 예제이다.얼마전에 코딩 테스트를 봤었는데 해당 문제가 나와 이참에 적어본다.우선 반복문으로 2단의 값을 출력해 보자 123for(var i = 1;i &lt;= 9;i++){ console.log(2 * i);}; 123452 4 6 8 . . . 정상적으로 출력된다. 이제 이 값을 하나의 변수에 넣어 보자 12345var result = '';for(var i = 1; i &lt;= 9; i++){ result += 2 * i + '\\n';};console.log(result); result에 2단의 값을 차례대로 대입하였더니 정상적으로 출력된다.이제 답 말고 구구단식도 같이 넣어 보자 12345var result = '';for(var i = 1;i &lt;= 9;i++){ result += '2' + 'x' + i + '=' + 2*i + '\\n';};console.log(result); 1234567892 x 1 = 2 2 x 2 = 4 2 x 3 = 6 2 x 4 = 8 2 x 5 = 10 2 x 6 = 12 2 x 7 = 14 2 x 8 = 16 2 x 9 = 18 조금 그럴싸해졌다.이제 중첩 반복문을 활용하여 1단부터 9단까지의 모든 구구단을 출력해 보자 123456var result = '';for(var i = 1;i &lt;= 9;i++){ for(var j = 1;j &lt;= 9;j++){ result += i + 'x' + j + '=' + i*j + '\\n'; };}; 완성이다. 로직을 살펴보자result가 선언되고 외부 반복문이 시작된다. i가 1인 상태에서 내부 반복문으로 들어간다. result에 대입되는 값을 해석해 보면 i에 문자열 x을 더하고 j값을 더한뒤 문자열 = 을 더하고 값을 더한뒤 줄바꿈 처리를 했다. 내부 반복문이 다시 실행된다. i값이 1상태에서 j는 2에서 반복문이 실행된다.i는 몇단인지 구분되는 값이 되겠다. 이런식으로 중첩되어 값을 계산하고 마지막엔 콘솔창에 값을 출력하게 된다.","link":"/2018/02/20/algorithm-multiplication/"},{"title":"자바스크립트 인덱스 구하기","text":"제이쿼리의 index()를 자바스크립트만으로 구현할 수 있다. HTML123456&lt;ul id=\"ul\"&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; javascript123456789var ul = document.getElementById('ul'), li = ul.getElementsByTagName('li');for (var i = 0; i &lt; li.length; i++) { (function (idx) { li[idx].onclick = function () { alert(idx); } })(i);}; 결과리스트를 클릭하면 인덱스를 구할 수 있다. 0 1 2 3 var ul = document.getElementById('ul'), li = ul.getElementsByTagName('li'); for (var i = 0; i < li.length; i++) { (function (idx) { li[idx].onclick = function () { alert(idx); } })(i); };","link":"/2018/01/15/javascript-get-index/"},{"title":"while 반복문","text":"while문은 조건을 검사하여 true일경우 계속 구문을 실행시키는 반복문이다. 123while (조건) { 구문} 12345678var i = 0;while (i &lt; 3) { console.log(i); i++;}// 0// 1// 2 do-while은 whild문과 비슷하지만 처음은 조건과 상관없이 구문을 실행하고 이후에 조건을 검사하여 true일때 구문을 실행한다. 123do { 구문} while (조건) 처음 구문을 실행하여 0이 출력되고, i는 3이 아니므로 로직이 실행이 안된다. 12345var i = 0;do { console.log(i);} while (i == 3)// 0","link":"/2018/01/16/javascript-while/"},{"title":"배열 메소드","text":"자바스크립트에서 자주 쓰이는 배열 메소드 정리, 추후 계속 업데이트 예정 concat()배열을 하나로 합칠 때 사용한다. 인자로 들어온 배열의 순서대로 합쳐진다. 1234567891011var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];var arr3 = [7, 8, 9];var wrap = arr1.concat(arr2, arr2, arr3);console.log(wrap);// (12) [1, 2, 3, 4, 5, 6, 4, 5, 6, 7, 8, 9]console.log(arr1);// (3) [1, 2, 3] forEach()주어진 함수를 배열 요소 각각에 대해 실행한다. 12345678var arr = ['a', 'b', 'c'];arr.forEach(function(element){ console.log(element); // a // b // c}); map()배열을 반복하고, 콜백함수가 리턴한 값으로 새 배열을 반환한다. 1234567891011121314var users = [ { name: '철수', age: 20 }, { name: '영희', age: 25 }, { name: '민수', age: 23 }, { name: '주연', age: 27 }];var usersName = users.map(function (element) { return element.name; // 각 요소의 nama 값만 반환});console.log(usersName);// (4) [\"철수\", \"영희\", \"민수\", \"주연\"] filter()배열을 반복하고, 콜백함수의 리턴값이 true인 요소로만 구성된 새 배열을 반환한다. 아래 예제는 age가 23 초과인 요소만 반환하였다. 1234567891011121314151617var users = [ { name: '철수', age: 20 }, { name: '영희', age: 25 }, { name: '민수', age: 23 }, { name: '주연', age: 27 }];var usersOld = users.filter(function (element) { return element.age &gt; 23;});console.log(usersOld);// (2) [{…}, {…}]// 0: {name: \"영희\", age: 25}// 1: {name: \"주연\", age: 27}// length: 2// __proto__: Array(0) sort()배열을 반복하고, 콜백함수의 리턴값이 true인 요소로만 구성된 새 배열을 반환한다. 아래 예제는 age가 23 초과인 요소만 반환하였다. 123456789101112131415var arr = [5, 2, 1, 3, 10, 4];arr.sort(function(a, b){ return a - b; // 오름차순});console.log(arr);// (6) [1, 2, 3, 4, 5, 10]arr.sort(function(a, b){ return b - a; // 내림차순});console.log(arr);// (6) [10, 5, 4, 3, 2, 1] indexOf()인자로 전달된 요소와 매치되는 첫번째 요소의 인덱스를 반환한다. 일치하는 요소가 없으면 -1을 반환한다. 1234var arr = ['a', 'b', 'c', 'd'];console.log(arr.indexOf('c')); // 2console.log(arr.indexOf('e')); // -1 every()함수의 리턴값이 false가 될 때 까지 배열 요소 각각에 대해 함수를 실행한다. 123456789var arr = [1, 2, 3, 4, 5];arr.every(function(element){ console.log(element); // 1 // 2 // 3 return element &lt; 3;}); References JavaScript 배열 메소드 ( Array method )Array.prototype.forEach()알아두면 좋은 자바스크립트 배열 메소드","link":"/2018/05/15/javascript-array-method/"},{"title":"IOS 스크롤 방지","text":"모달 팝업에서 백그라운드 영역의 스크롤을 방지하고자 할 때 Android는 body에 overflow: hidden 속성만 줘도 스크롤이 방지되지만 IOS의 경우는 먹히지 않는다.이럴 경우 body를 position: fixed 로 고정시킨 뒤 스크롤, 터치, 마우스 휠 이벤트를 막아버리면 된다. 12345.scrollOff { position: fixed; overflow: hidden; height: 100%;} 1234567// ios 스크롤 방지$('body').addClass('scrollOff').on('scroll touchmove mousewheel', function(e){ e.preventDefault();});// ios 스크롤 방지$('body').removeClass('scrollOff').off('scroll touchmove mousewheel');","link":"/2018/06/11/ios-scroll-off/"},{"title":"정규표현식","text":"정규표현식은 문자열에 포함된 문자 조합을 찾기 위해 사용되거나 그 문자열을 다른 문자열로 치환해 주는 패턴이다. 예를 들면 회원가입 화면에서 사용자로 부터 입력받는 전화번호가 유효한지 체크할 필요가 있을 때 정규표현식을 사용하면 간단하게 처리할 수 있다. 1234var tel = '0101234567팔';var regExp = /^[0-9]+$/;console.log(regExp.test(tel)); // false 정규표현식은 하나의 언어라고 할 만큼 모든것을 다루기에는 너무 방대하다. 정규표현식 패턴은 zvon의 정규표현식 tutorials에서 확인할 수 있다. 정규표현식은 리터럴 표기법과 생성자 함수로 생성할 수 있다. 리터널 방식1var re = /ab + c/; 리터널 방식은 스크립트가 불어와질 때 컴파일 된다. 정규직이 상수라면 이렇게 사용하는 것이 성능을 향상시킨다. 생성자 함수 방식1var re = new RegExp(\"ab + c\"); 생성자 함수 방식은 정규식이 실행 시점에 컴파일 된다. 정규식의 패턴이 변경될 수 있는 경우, 혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는 경우에 생성자 함수 방식을 쓴다. 정규 표현식 리터럴은 아래와 같이 표현한다. 1var re = /pa/i; / 는 시작, 종료기호 이며, pa는 패턴, i는 프래그 이다. 자바스크립트에서 정규표현식 패턴들은 RegExp의 exec 메소드와 test 메소드, 그리고 String의 match메소드, replace메소드, search메소드, split 메소드와 함께 쓰인다. 메소드 설명 RegExp.exec() 어떤 문자열에서 정규표현식과 일치하는 문자열 검색을 수행한다. 결과로 배열을 리턴하거나 null을 반환한다. RegExp.test() 대상 문자열 속에 일치하는 문자열이 포함되어 있는지 검사하고 true 또는 false를 반환한다. String.match() 문자열이 정규식과 매치되는 부분을 검색한다. String.replace() 대응되는 문자열을 찾아 다른 문자열로 치환하는 String 메소드이다. String.search() 대응되는 문자열이 있는지 검사하는 String 메소드 이다. 대응된 부분의 인덱스를 반환한다. 대응되는 문자열을 찾지 못했다면 -1을 반환한다. String.split() 정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 String 메소드이다. 123456789101112var str = 'this is a pen.';var regexr = /is/ig;// RegExp 객체의 메소드console.log(regexr.exec(str)); // [\"is\", index: 2, input: \"this is a pen.\", groups: undefined]console.log(regexr.test(str)); // true// String 객체의 메소드console.log(str.match(regexr)); // (2) [\"is\", \"is\"]console.log(str.replace(regexr, 'is')); // this is a pen.console.log(str.search(regexr)); // 2console.log(str.split(regexr)); // (3) [\"th\", \" \", \" a pen.\"] References 정규표현식5.26 RegExp 정규표현식정규 표현식","link":"/2018/03/02/javascript-regexp/"},{"title":"생성자 함수에서의 This","text":"객체를 생성하는 방법은 크게 객체 리터널 방식과 생성자 함수 방식, Object() 생성자 함수 방식이 있다. 123var obj = {};var obj = new Func();var obj = new Object(); 이 세가지 중 생성자 함수의 this를 알아보겠다. 생성자 함수는 기존 함수에 new 키워드를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 일반 함수에서의 this는 window를 가르키지만 생성자 함수에서는 다르게 동작한다. 이때문에 원치 않은 상황이 나타날 수 있는데, 이를 피하기 위해 생성자 함수 이름의 첫 글자는 대문자로 작성하기를 권장하고 있다. 일반 함수의 this1234function func(){ console.log(this);};func(); // window 생성자 함수의 this1234567function Func(name){ this.name = name; console.log(this); return this;};var obj = new Func(\"foo\");console.log(obj); // Func {name: \"foo\"} 생성자 함수의 this 는 메서드 함수 호출과의 this 바인딩과 다르게 동한다. 이를 이해하려면 생성자 함수가 어떻게 동작하는지 알아야 한다. 위의 코드를 보면 생성자 함수가 정의되었고 인자값으로 name 프로퍼티의 값을 받고 있다. new 키워드를 사용해서 생성자 함수를 호출하면 우선 빈 객체가 생성되고, 이 객체는 생성자 함수의 프로토타입을 참조한다. 생성자 함수가 실행되면서 동적으로 name 프로퍼티를 추가시킨다. this로 바인딩한 객체가 생성자 함수의 리턴값으로 반환되서 obj 변수에 저장된다.","link":"/2018/11/02/javascript-constructor-this/"},{"title":"자바스크립트 This","text":"this는 함수가 호출되면 함수 내부로 암묵적으로 전달된다.this는 메서드를 호출한 객체가 저장되어 있는 속성이다.메서드 뿐만 아니라 일반 함수를 호출할때도 만들어 지며, 이벤트 리스너가 호출될 때에도 만들어진다. 문제는 this 속성에 저장되는 값이 동일한 값이 아니라 각각 다른점이다. this가 만들어지는 경우 일반 함수에서의 this 중첩 함수에서의 this 이벤트 리스너에서의 this 메서드에서의 this 메서드 내부의 중첩 함수의 this 일반 함수에서의 this1234function func(){ console.log(this); // window};func(); 일반 함수 내부에서는 this는 전역객체인 window가 된다. 자바스크립트의 모든 전역 변수는 전역객체의 프로퍼티이다. 중첩 함수에서의 this1234567function func(){ function func2(){ console.log(this); // window }; func2();};func(); 일반 중첩 함수에서의 this 도 window 가 된다. 이벤트 리스너에서의 this12345window.onload = function(){ document.getElementById(\"btn\").addEventListener(\"click\", function(){ console.log(this); });}; 이벤트 리스너에서의 this는 이벤트를 발생시킨 객체가 된다. 메서드에서의 this123456var obj = { func: function(){ console.log(this); // object{}; }};obj.func(); 메서드에서의 this는 이벤트를 발생시킨 객체가 된다. 메서드 내부의 중첩 함수의 this123456789var obj = { func: function(){ function func2(){ console.log(this); // window }; func2(); }};obj.func(); 메서드의 this 와는 다르게 window 를 가리킨다. 이는 내부 함수 호출 패턴을 정의해 놓지 않기 때문이다. 내부함수도 결국 함수이므로 이를 호출할 때는 함수 호출로 취급된다.중첩함수가 메서드를 포함한 객체를 참조하려면 부모함수의 this를 내부함수가 접근 가능한 변수에 저장하면 된다.보통 관례상 this 값을 저장하는 변수의 이름을 that 이라고 선언한다. 12345678910var obj = { func: function(){ var that = this; function func2(){ console.log(that); // window }; func2(); }};obj.func(); 자바스크립트는 위와 같은 바인딩의 한계를 극복하려고 this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공한다.제이쿼리 등 자바스크립트 라이버리들의 경우 bind 라는 메서드를 통해, 사용자가 원하는 객체를 this에 바인딩 하는 기능을 제공하고 있다.","link":"/2018/11/01/javascript-this/"},{"title":"함수 메소드(call, apply, bind)","text":"함수의 기본 메소드중 call, apply, bind 에 대해 알아보자 자바스크립트에서 상속개념을 자주 쓰다보면 불필요한 메소드에 프로토타입까지 상속받아 오기 때문에 메모리 낭비가 심해진다. 이때 다른 객체의 메소드를 가져와 쓸 수 있는데 그 기능을 가진 메소드가 call과 apply 이다. call 메소드 먼저 살펴보겠다. call12345func.call(obj, a, b);func = 가져올 메소드call = call 메소드obj = 메소드를 사용할(현재) 객체a, b = 메소드에 전달할 인자 1234567var obj1 = { name: \"obj1\", funcThis: function(){ return this; }};console.log(obj1.funcThis()); // Object {name: \"obj1\"} obj1 객체에 funcThis 메소드를 추가했다. funcThis 메소드는 자신을 감싼 obj1객체를 리턴하고 있다. 12345678910var obj1 = { name: \"obj1\", funcThis: function(){ return this; }};var obj2 = { name: \"obj2\"};console.log(obj1.funcThis.call(obj2)); // Object {name: \"obj2\"} call 메소드를 이용하여 obj1 의 funcThis 메소드를 obj2 객체에서 실행한다. obj2객체를 리턴하고 있다. 아무 값을 안넣으면(null) window를 반환한다. call 과 형제격인 apply 메소드는 call 메소드와 같지만 한가지 다른점이 있다. call은 인자값을 하나 하나 전달하지만 apply 메소드는 인자값을 배열로 전달한다. apply12345func.apply(obj, [arr]);func = 가져올 메소드apply = apply 메소드obj = 메소드를 사용할(현재) 객체arr = 메소드에 전달할 인자 목록 call 과 apply 는 보통 함수 내 arguments 객체와 같이 사용하는 모습을 많이 볼 수 있다. 처음에는 어려워 보이지만, 단순하게 보면 결국 arguments 객체에 다른 메소드를 빌려와 쓰는것으로 보면 된다. arguments 객체는 배열처럼 보이지만 실제 배열이 아닌 유사배열객체이기 때문에 배열 메소드가 없다(length 제외). 아래 구문은 arguments에 없는 배열의 메소드를 가져와 쓰는 것이다. 1234function func(){ console.log(Array.prototype.slice.call(arguments, 0, 2));};func(\"눈\", \"누\", \"난\", \"나\"); // [\"눈\", \"누\"] 위 함수를 보면 배열의 프로토타입에 있는 slice 메소드를 arguments 객체에서 사용하는 것을 알 수 있다. 12345slice 메소드 : 문자열의 일정 부분을 반환obj.slice(start, end);obj = 필수. 반환할 배열 객체start = 필수. 지정된 부분의 시작입start = 선택. 지정된 부분의 끝 1234function func(){ console.log(Array.prototype.join.call(arguments));};func(\"눈\", \"누\", \"난\", \"나\"); // 눈-누-난-나 join 메소드 : 인자값으로 넘겨진 구문을 모든 배열 요소에 추가한다. 123obj.join(&quot;val&quot;);obj = 필수. 반환할 배열 객체val = 선택. 추가할 문자열 이다. 아무값도 안넣을 경우 쉼표(,)로 대체된다. bindbind 함수는 함수가 가르키는 this만 바꾸고 호출은 하지 않는다. 1234567891011var obj1 = { name: \"obj1\", funcThis: function(){ console.log(this); }};var obj2 = { name: \"obj2\"};var func = obj1.funcThis.bind(obj2);func(); // Object {name: \"obj2\"} obj1 의 funcThis 메서드를 obj2 객체로 가져와서 func 변수에 할당했다. func 함수를 실행하면 obj2 객체가 출력된다.","link":"/2018/11/08/javascript-function-method/"},{"title":"var, let, const 차이","text":"var는 변수를 선언하는 키워드이며, ES6부터 let과 const가 추가되었다.var는 함수 스코프를 가지고 let과 const는 블록 스코프를 가진다. 여기서 스코프란 코드가 실행되는 유효범휘이다. 블록 스코프블록 스코프는 중괄호{}로 감싸진 범위를 말한다. 아래는 조건문(if), 반복문(for), 함수(function)가 블록 스코프를 가지고 있는 모습이다. 1234567891011if (true) { // 블록 스코프}for (var i = 0; i &lt; 10; i++) { // 블록 스코프}function func() { // 블록 스코프} var기존의 var는 위 세개중 함수에서만 스코프를 가진다. 1234567891011121314151617if (true) { var a = 1;}console.log(a);// 1for (var i = 0; i &lt; 1; i++) { var b = 2;}console.log(b);// 2function func() { var c = 3;}console.log(c);// Uncaught ReferenceError: foo is not defined at window.onload var는 중복 선언이 가능하다. 1234var a = 1; a = 2;console.log(a);// 2 let, constES6부터 추가된 let, const는 조건문과 반복문에도 스코프를 가진다. 12345678910111213141516171819202122232425262728293031if (true) { let a = 1; const b = 2; console.log(a); // 1 console.log(B); // 2}console.log(a);// Uncaught ReferenceError: a is not defined at window.onloadconsole.log(b);// Uncaught ReferenceError: a is not defined at window.onloadfor (var i = 0; i &lt; 1; i++) { let c = 3; const d = 4; console.log(c); // 3 console.log(d); // 4}console.log(c); // Uncaught ReferenceError: a is not defined at window.onloadconsole.log(d); // Uncaught ReferenceError: a is not defined at window.onloadfunction func() { let e = 5; const f = 6; console.log(e); // 5 console.log(f); // 6}func();console.log(e);// Uncaught ReferenceError: foo is not defined at window.onloadconsole.log(f);// Uncaught ReferenceError: foo is not defined at window.onload let과 const의 차이는 const 가 좀 더 엄격하다. let은 중복선언이 되지만 const는 중복선언이 안되기 때문에 변수가 선언될 때 값을 할당하여야 한다. const는 DB환경정보, API응답값 등 변하지 않을 값을 담을 때 사용한다. 12345678let a; a = 1;console.log(a);// 1const b; b = 2;// Uncaught TypeError: Assignment to constant variable. 결론 var은 함수 스코프에서만 유효 let, const는 블록 스코프에서 유효 const는 선언과 동시에 할당이 일어나야하고, 재할당이 불가 References 자바스크립트 변수와 스코프(유효범위)","link":"/2019/06/05/javascript-block-scope/"},{"title":"프로토타입(Prototype)","text":"자바스크립트는 클래스라는 개념이 없다. 클래스는 자바, 파이썬, 루바 등 객체지향 언어에서 빠질수 없는 개념이다. 하지만 자바스크립트도 객체지향언어인데, 클래스 대신 프로토타입(Prototype)을 기반으로 클래스의 상속 기능을 흉내내도록 구현하여 사용한다. 그래서 자바스크립트는 프로토타입 기반의 객체 지향 언어라고 한다. 자바스크립트의 모든 객체는 자신의 부모역할을 담당하는 객체와 연결되어 있다. 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 프로토타입 이라 한다. 프로토타입은 언제 쓰는가123456789101112function Person() { this.eyes = 2; this.nose = 1;}var kang = new Person();var park = new Person();console.log(kang.eyes); // 2console.log(kang.nose); // 1console.log(park.eyes); // 2console.log(park.nose); // 1 kang과 park은 eyes와 nose를 공통적으로 가지고 있는데, 메모리는 eyes와 nose가 두개씩 총 4개에 할당된다. 객체를 100개를 만들면 200개의 변수가 메모리에 할당된다. 이런 메모리 낭비 문제를 프로토타입으로 해결할 수 있다. 12345678910function Person() {}Person.prototype.eyes = 2;Person.prototype.nose = 1;var kang = new Person();var park = new Person();console.log(kang.eyes); // 2console.log(park.nose); // 1 간략히 설명하면 Person.prototype라는 빈 객체가 어딘가에 존재하고 Person함수로부터 생성된 객체(kang, park)은 어딘가에 존재하는 객체의 값을 모두 갖다쓸 수 있다. 즉, eyes와 nose를 어딘가에 있는 빈 객체(Person.prototype)에 넣어두고, kim과 park이 공유해서 사용하는 것이다. 프로토타입 객체와 프로토타입 링크자바스크립트에서는 프로토타입 객체(prototype object)와 프로토타입 링크(prototype link)라는 것이 존재한다. 그리고 이 둘을 통틀어 프로토타입이라고 부른다. 객체는 언제나 함수로 생성된다.12function Person() {} // 함수var obj = new Person(); // new 키워드와 함수로 객체를 생성 obj 객체는 Person이라는 함수로 생성된 객체이다. 일반적인 객체 리터럴 방식도 예외는 아니다. 1var obj = {}; 객체 리터럴 방식으로 객체를 생성하였는데 이 방식은 아래 방식과 같다. 1var obj = new Object(); Object도 객체를 만드는 생성자 함수이다. Object와 마찬가지로 Function, Array도 모두 생성자 함수이다. 이 사실은 프로토타입과 밀접하게 관련이 있는데 함수가 정의될 때는 2가지 일이 동시에 일어나기 때문이다. 함수가 정의될 때1. 해당 함수에 constructor(생성자) 자격 부여constructor 자격이 부여되면 new 키워드를 통해 객체를 만들수 있다. 오직 함수만 new 키워드를 사용할 수 있다. 123var obj = {}; // 객체 선언var a = new obj();// Uncaught TypeError: obj is not a constructor obj는 생성자 자격이 없다고 나온다. 오직 함수만이 constructor 자격을 가질 수 있다. 2. 해당 함수의 프로토타입 객체 생성 및 연결함수를 정의하면 함수만 생성되는 것이 아니라 프로토타입 객체도 같이 생성이 된다. 생성된 함수는 prototype라는 속성을 통해 프로토타입 객체에 접근할 수 있다. 프로토타입 객체는 일반적인 객체와 같으며, 기본적인 속성으로 constructor와 __proto__를 가지고 있다. 12345function Person() {}console.log(Person.prototype);// {constructor: ƒ}// &gt; constructor: ƒ Person()// &gt; __proto__: Object constructor는 프로토타입 객체와 같이 생성되었던 함수를 가르키고 있다. __proto__은 프로토타입 링크다. 프로토타입 링크는 아래에서 다시 알아보도록 하고 위에서 언급된 eyes, nose예제를 다시 살펴보겠다. 1234567891011121314function Person() {}Person.prototype.eyes = 2;Person.prototype.nose = 1;var kang = new Person();var park = new Person();console.log(Person.prototype);// {eyes: 2, nose: 1, constructor: ƒ}// &gt; eyes: 2// &gt; nose: 1// &gt; constructor: ƒ Person()// &gt; __proto__: Object Person.prototype라는 빈 객체가 어딘가에 존재하고, 그 객체에 eyes, nose값을 할당한 것을 확인할 수 있다. 프로토타입 객체는 일반적인 객체이므로 속성을 마음대로 추가, 삭제할 수 있으며 kang과 park은 Person함수를 통해 생성되었으니 Person.prototype를 참조할 수 있게 된다. 프로토타입 링크12345678function Person() {}Person.prototype.eyes = 2;var kang = new Person();console.log(kang);// Person {}console.log(kang.eyes);// 2 kang객체에 따로 eyes속성을 선언하지 않았지만 kang.eyes를 실행하면 2라는 값을 참조한다. 위에서 설명했듯이 프로토타입 객체의 eyes속성을 참조한 것인데, 이것이 가능한 이유는 kang이 가지고 있는 __proto__속성이 프로토타입 객체를 가르키고 있기 때문이다. 12console.log(kang.__proto__);// {eyes: 2, nose: 1, constructor: ƒ} kang.__proto__ 속성을 확인해보니 프로토타입 객체를 가르키고 있다. kang객체는 직접 eyes속성을 가지고 있지 않아 eyes속성을 찾을 때 까지 상위 프로토타입을 탐색한다. 최상위인 Object의 프로토타입 객체까지 도달했는데도 못찾을 경우 undefined를 리턴한다. 이렇게 __proto__속성을 통해 상위 프로토타입과 연결되어있는 형태를 프로토타입 체인이라고 한다. 이런 프로토타입 체인 구조 때문에 모든 객체는 Object의 자식이라고 하며, Object에 있는 모드 속성을 사용할 수 있다. References [Javascript ] 프로토타입 이해하기Javascript 기초 - Object prototype 이해하기JavaScript : 프로토타입(prototype) 이해","link":"/2018/12/17/javascript-prototype/"},{"title":"탭메뉴(tab menu)","text":"vanilla JS로 제작된 기본 탭 메뉴 구현 window.addEventListener('load', function(){ var tab = document.getElementById('tab'), btn = tab.getElementsByClassName('btn')[0], cnt = tab.getElementsByClassName('cnt')[0], index = 0; btn.children[0].classList.add('on'); cnt.children[0].classList.add('on'); for(var i = 0;i < btn.children.length;i++){ (function(target){ btn.children[target].addEventListener('click', function(){ tabOn(target); }); })(i); }; function tabOn(target){ for(var i = 0;i < btn.children.length;i++){ btn.children[i].classList.remove('on'); cnt.children[i].classList.remove('on'); }; btn.children[target].classList.add('on'); cnt.children[target].classList.add('on'); } }); .uiWrap * { margin: 0; padding: 0; } .uiWrap ul li:before, .uiWrap ol li:before { display:none; } #tab { border: 1px solid #ccc; width: 400px; } #tab .btn:after { content: ''; display: block; clear: both; } #tab .btn button { float: left; border: 0; width: 25%; height: 30px; cursor: pointer; outline: none; background-color: #ccc; } #tab .btn button:hover { background-color: #fff; } #tab .btn button.on { background-color: #fff; } #tab .cnt div { display: none; } #tab .cnt div.on { display: block; } 01 02 03 04 content01 content01 content01 content01 content01 content01 content01 content01 content01 content01 content02 content02 content02 content02 content02 content02 content02 content02 content02 content02 content03 content03 content03 content03 content03 content03 content03 content03 content03 content03 content04 content04 content04 content04 content04 content04 content04 content04 content04 content04 HTML1234567891011121314&lt;div id=\"tab\"&gt; &lt;div class=\"btn\"&gt; &lt;button type=\"button\"&gt;01&lt;/button&gt; &lt;button type=\"button\"&gt;02&lt;/button&gt; &lt;button type=\"button\"&gt;03&lt;/button&gt; &lt;button type=\"button\"&gt;04&lt;/button&gt; &lt;/div&gt; &lt;div class=\"cnt\"&gt; &lt;div&gt;content01 content01 content01 content01 content01 content01 content01 content01 content01 content01&lt;/div&gt; &lt;div&gt;content02 content02 content02 content02 content02 content02 content02 content02 content02 content02&lt;/div&gt; &lt;div&gt;content03 content03 content03 content03 content03 content03 content03 content03 content03 content03&lt;/div&gt; &lt;div&gt;content04 content04 content04 content04 content04 content04 content04 content04 content04 content04&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536#tab { border: 1px solid #ccc; width: 400px;}#tab .btn:after { content: ''; display: block; clear: both;}#tab .btn button { float: left; border: 0; width: 25%; height: 30px; cursor: pointer; outline: none; background-color: #ccc;}#tab .btn button:hover { background-color: #fff;}#tab .btn button.on { background-color: #fff;}#tab .cnt div { display: none;}#tab .cnt div.on { display: block;} javascript12345678910111213141516171819202122232425262728window.addEventListener('load', function(){ var tab = document.getElementById('tab'), btn = tab.getElementsByClassName('btn')[0], cnt = tab.getElementsByClassName('cnt')[0], index = 0; btn.children[0].classList.add('on'); cnt.children[0].classList.add('on'); for(var i = 0;i &lt; btn.children.length;i++){ (function(target){ btn.children[target].addEventListener('click', function(){ tabOn(target); }); })(i); }; function tabOn(target){ for(var i = 0;i &lt; btn.children.length;i++){ btn.children[i].classList.remove('on'); cnt.children[i].classList.remove('on'); }; btn.children[target].classList.add('on'); cnt.children[target].classList.add('on'); }});","link":"/2019/04/08/ui-tab-menu/"},{"title":"슬라이드 배너(slide banner)","text":"vanilla JS로 만들어본 기본 슬라이드 배너 조건 플러그인 없이 자바스크립트만 활용 다음, 이전 버튼으로 슬라이드 조작 가능 인디게이터는 슬라이드 갯수에 맞게 자동으로 생성 자동재생, 일시정지 버튼으로 웹 접근성 준수 구현 window.addEventListener('load', function(){ var MOVEING_PX = 4, AUTO_TIME = 2000, slide = document.getElementById('slide'), indi = document.createElement('ul'), slideCnt = slide.getElementsByClassName('cnt'), slideCntItem = slideCnt[0].getElementsByTagName('li'), prevBtn = slide.getElementsByClassName('prev'), nextBtn = slide.getElementsByClassName('next'), playBtn = slide.getElementsByClassName('play'), stopBtn = slide.getElementsByClassName('stop'), playSet = null, before = 0, after = 0, moveIng = false; // init slideCntItem[0].style.left = 0; playBtn[0].style.display = 'block'; var indi = document.createElement('ul'); for(var i = 0;i < slideCntItem.length;i++){ indi.innerHTML += ''; }; indi.classList.add('indi'); indi.children[0].classList.add('on'); slide.append(indi); for(var j = 0;j < indi.children.length;j++){ indiClick(j); }; // initEvnet nextBtn[0].addEventListener('click', function(e){ if(!moveIng){ after++; if(after >= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }); prevBtn[0].addEventListener('click', function(e){ if(!moveIng){ after--; if(after < 0){ after = slideCntItem.length - 1; }; move(after, before); before = after; }; }); playBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'none'; stopBtn[0].style.display = 'block'; playSet = setInterval(function(){ if(!moveIng){ after++; if(after >= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }, AUTO_TIME); }); stopBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'block'; stopBtn[0].style.display = 'none'; clearInterval(playSet); }); function indiClick(target){ indi.children[target].addEventListener('click', function(){ if(!moveIng){ after = target; if(after > before){ move(after, before, 'next'); }else if(after < before){ move(after, before); }; before = after; }; }); } function move(after, before, type){ var nextX = type === 'next' ? slide.offsetWidth : slide.offsetWidth * -1, prevX = 0, set = null; set = setInterval(function(){ moveIng = true; if(type === 'next'){ nextX -= MOVEING_PX; slideCntItem[after].style.left = nextX + 'px'; if(nextX = 0){ clearInterval(set); nextX = slide.offsetWidth * -1; moveIng = false; }; prevX += MOVEING_PX; }; slideCntItem[before].style.left = prevX + 'px'; }); indi.children[before].classList.remove('on'); indi.children[after].classList.add('on'); } }); .uiWrap * { margin: 0; padding: 0; } .uiWrap ul li, .uiWrap ol li { list-style: none; } .uiWrap ul li:before, .uiWrap ol li:before { display: none; } #slide { position: relative; overflow: hidden; width: 400px; height: 300px; } #slide .cnt>li { position: absolute; top: 0; left: 400px; margin: 0; width: 400px; height: 300px; text-align: center; font-size: 30px; line-height: 300px; color: #fff; } #slide .cnt>li:nth-child(1) { background-color: red; } #slide .cnt>li:nth-child(2) { background-color: orange; } #slide .cnt>li:nth-child(3) { background-color: green; } #slide .cnt>li:nth-child(4) { background-color: blue; } #slide .btn>button { position: absolute; top: 50%; transform: translateY(-50%); border: 0; padding: 5px; background-color: #fff; } #slide .btn .prev { left: 5px; } #slide .btn .next { right: 5px; } #slide .auto>button { display: none; position: absolute; bottom: 5px; right: 5px; border: 0; padding: 5px; background-color: #fff; } #slide .indi { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); margin: 0; } #slide .indi:after { content: ''; display: block; clear: both; } #slide .indi>li { float: left; margin: 0 0 0 5px; border-radius: 50%; width: 12px; height: 12px; cursor: pointer; opacity: .5; background-color: #fff; } #slide .indi>li.on { opacity: 1 } #slide .indi>li:first-child { margin-left: 0 } 1 2 3 4 prev next stop play HTML12345678910111213141516&lt;div id=\"slide\"&gt; &lt;ul class=\"cnt\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"btn\"&gt; &lt;button type=\"button\" class=\"prev\"&gt;prev&lt;/button&gt; &lt;button type=\"button\" class=\"next\"&gt;next&lt;/button&gt; &lt;/div&gt; &lt;div class=\"auto\"&gt; &lt;button type=\"button\" class=\"stop\"&gt;stop&lt;/button&gt; &lt;button type=\"button\" class=\"play\"&gt;play&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#slide { position: relative; overflow: hidden; width: 400px; height: 300px;}#slide .cnt&gt;li { position: absolute; top: 0; left: 400px; width: 400px; height: 300px; text-align: center; font-size: 30px; line-height: 300px; color: #fff;}#slide .cnt&gt;li:nth-child(1) { background-color: red;}#slide .cnt&gt;li:nth-child(2) { background-color: orange;}#slide .cnt&gt;li:nth-child(3) { background-color: green;}#slide .cnt&gt;li:nth-child(4) { background-color: blue;}#slide .btn&gt;button { position: absolute; top: 50%; transform: translateY(-50%); border: 0; padding: 5px; background-color: #fff;}#slide .btn .prev { left: 5px;}#slide .btn .next { right: 5px;}#slide .auto&gt;button { display: none; position: absolute; bottom: 5px; right: 5px; border: 0; padding: 5px; background-color: #fff;}#slide .indi { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%)}#slide .indi:after { content: ''; display: block; clear: both;}#slide .indi&gt;li { float: left; margin-left: 5px; border-radius: 50%; width: 12px; height: 12px; cursor: pointer; opacity: .5; background-color: #fff;}#slide .indi&gt;li.on { opacity: 1}#slide .indi&gt;li:first-child { margin-left: 0} javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122window.addEventListener('load', function(){ var MOVEING_PX = 4, AUTO_TIME = 2000, slide = document.getElementById('slide'), indi = document.createElement('ul'), slideCnt = slide.getElementsByClassName('cnt'), slideCntItem = slideCnt[0].getElementsByTagName('li'), prevBtn = slide.getElementsByClassName('prev'), nextBtn = slide.getElementsByClassName('next'), playBtn = slide.getElementsByClassName('play'), stopBtn = slide.getElementsByClassName('stop'), playSet = null, before = 0, after = 0, moveIng = false; // init slideCntItem[0].style.left = 0; playBtn[0].style.display = 'block'; var indi = document.createElement('ul'); for(var i = 0;i &lt; slideCntItem.length;i++){ indi.innerHTML += '&lt;li&gt;&lt;/li&gt;'; }; indi.classList.add('indi'); indi.children[0].classList.add('on'); slide.append(indi); for(var j = 0;j &lt; indi.children.length;j++){ indiClick(j); }; // initEvnet nextBtn[0].addEventListener('click', function(e){ if(!moveIng){ after++; if(after &gt;= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }); prevBtn[0].addEventListener('click', function(e){ if(!moveIng){ after--; if(after &lt; 0){ after = slideCntItem.length - 1; }; move(after, before); before = after; }; }); playBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'none'; stopBtn[0].style.display = 'block'; playSet = setInterval(function(){ if(!moveIng){ after++; if(after &gt;= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }, AUTO_TIME); }); stopBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'block'; stopBtn[0].style.display = 'none'; clearInterval(playSet); }); function indiClick(target){ indi.children[target].addEventListener('click', function(){ if(!moveIng){ after = target; if(after &gt; before){ move(after, before, 'next'); }else if(after &lt; before){ move(after, before); }; before = after; }; }); } function move(after, before, type){ var nextX = type === 'next' ? slide.offsetWidth : slide.offsetWidth * -1, prevX = 0, set = null; set = setInterval(function(){ moveIng = true; if(type === 'next'){ nextX -= MOVEING_PX; slideCntItem[after].style.left = nextX + 'px'; if(nextX &lt;= 0){ clearInterval(set); nextX = slide.offsetWidth; moveIng = false; }; prevX -= MOVEING_PX; }else{ nextX += MOVEING_PX; slideCntItem[after].style.left = nextX + 'px'; if(nextX &gt;= 0){ clearInterval(set); nextX = slide.offsetWidth * -1; moveIng = false; }; prevX += MOVEING_PX; }; slideCntItem[before].style.left = prevX + 'px'; }); indi.children[before].classList.remove('on'); indi.children[after].classList.add('on'); }});","link":"/2019/04/10/ui-slide-banner/"},{"title":"Web Technology Terminology","text":"틈틈히 웹 관련 용어를 정리하는 곳 용어 설명 dump 프로그램 디버그 또는 시스템 테스트의 목적을 위해 기록되는 파일 temp 임시 폴더","link":"/2019/03/25/web-technology-terminology/"},{"title":"깃 명령어","text":"자주 쓴 명령어 위주로 작성, 추후 계속 추가 예정 초기화 깃 초기화 : 기존 디렉토리를 git 저장소로 만든다.$ git init 깃 상태 확인 : 현재 작업중인 브랜치와 파일 상태를 알려준다.$ git status 설정 전역 사용자 이름 생성$ git config --global user.name &quot;your name&quot; 전역 사용자 이메일 생성$ git config --global user.email &quot;your_email@youremail.com&quot; 저장소별 사용자 이름 생성$ git config user.name &quot;your name&quot; 저장소별 사용자 이메일 생성$ git config user.email &quot;your_email@youremail.com&quot; 사용자 설정이 되어 있지 않으면 깃허브의 저장소에 커밋 이력 및 작성자의 아이콘도 ? 로 표시된다. 웬만하면 사용자 설정을 해주도록 하자 저장소 복제하기$ git clone &quot;url&quot; 저장소 추가하기$ git remote add origin &quot;url&quot; 로컬저장소가 바라보고 있는 저장소의 정보 확인$ git remote -v 전역 설정 정보 조회$ git config --global --list 저장소 정보 조회$ git config --list 파일 추가 및 업로드 스테이지에 수정된 파일 업로드$ git add 'file name' 스테이지에 수정된 모든 파일 업로드$ git add . 커밋하기$ git commit -m 'message' 원격 저장소에 업로드$ git push origin master 원격 저장소에서 다운로드$ git pull origin master 되돌리기 스테이지에 올라간 파일 전부 내리기$ git reset 이력 모든 이력 보기$ git log 이력 나가기$ q 이력과 변경사항을 함께 보기$ git log -p 브랜치 지역 브랜치 목록 보기$ git branch 원격 저장소 브랜치 목록 보기$ git branch -r 지역 브랜치 및 원격 저장소 모든 브랜치 목록 보기$ git branch -a 브랜치 생성하기$ git branch &quot;branch name&quot; 해당 브랜치로 체크아웃 하기$ git checkout &quot;branch name&quot; 브랜치를 생성하고 생성된 체크아웃 하기$ git checkout -b &quot;branch name&quot; 해당 브랜치 삭제하기$ git branch -d &quot;branch name&quot; 해당 브랜치 강제 삭제하기$ git branch -D &quot;branch name&quot;","link":"/2019/10/01/git-command/"},{"title":"전체동의 체크박스(agree checkbox)","text":"vanilla JS로 만들어진 전체동의 체크박스, 보통 이용 약관에 많이 사용되된다. 조건 전체동의 클릭 시 모든 체크박스 체크 전체동의 클릭 해제 시 모든 체크박스 체크 해제 전체동의 체크박스 외 체크박스가 모두 체크 될 시 전체동의 체크박스 체크 전체동의 체크박스 외 체크박스가 모두 체크 해제 될 시 전체동의 체크박스 체크 해제 구현 window.onload = function(){ var checkWrap = document.getElementById('checkWrap'), check = checkWrap.getElementsByTagName('input'); checkWrap.addEventListener('click', function(e){ var target = e.target, checkNum = 0; if(target === check[0]){ if(target.checked){ for(var i = 1;i < check.length;i++){ check[i].checked = true; }; }else{ for(var i = 1;i < check.length;i++){ check[i].checked = false; }; }; }else{ for(var i = 1;i < check.length;i++){ if(check[i].checked){ checkNum++; }; }; if(checkNum >= check.length - 1){ check[0].checked = true; }else{ check[0].checked = false; }; }; }); }; .uiWrap * { margin: 0; padding: 0; } .uiWrap ul li:before, .uiWrap ol li:before { display:none; } #checkWrap { width: 120px; } #checkWrap label { display: block; margin: 5px; font-size: 14px; } #checkWrap label input[type=\"checkbox\"] { margin-right: 5px; width: 20px; height: 20px; vertical-align: middle; } #checkWrap label:first-child input[type=\"checkbox\"] { width: 30px; height: 30px; } 전체 동의 동의 동의 동의 HTML123456&lt;div id=\"checkWrap\"&gt; &lt;label for=\"cheeck01\"&gt;&lt;input type=\"checkbox\" id=\"cheeck01\" /&gt;전체 동의&lt;/label&gt; &lt;label for=\"cheeck02\"&gt;&lt;input type=\"checkbox\" id=\"cheeck02\" /&gt;동의&lt;/label&gt; &lt;label for=\"cheeck03\"&gt;&lt;input type=\"checkbox\" id=\"cheeck03\" /&gt;동의&lt;/label&gt; &lt;label for=\"cheeck04\"&gt;&lt;input type=\"checkbox\" id=\"cheeck04\" /&gt;동의&lt;/label&gt;&lt;/div&gt; css123456789101112131415161718192021#checkWrap { width: 120px;}#checkWrap label { display: block; margin: 5px; font-size: 14px;}#checkWrap label input[type=\"checkbox\"] { margin-right: 5px; width: 20px; height: 20px; vertical-align: middle;}#checkWrap label:first-child input[type=\"checkbox\"] { width: 30px; height: 30px;} javascript123456789101112131415161718192021222324252627282930window.onload = function(){ var checkWrap = document.getElementById('checkWrap'), check = checkWrap.getElementsByTagName('input'); checkWrap.addEventListener('click', function(e){ var target = e.target, checkNum = 0; if(target === check[0]){ if(target.checked){ for(var i = 1;i &lt; check.length;i++){ check[i].checked = true; }; }else{ for(var i = 1;i &lt; check.length;i++){ check[i].checked = false; }; }; }else{ for(var i = 1;i &lt; check.length;i++){ if(check[i].checked){ checkNum++; }; }; if(checkNum &gt;= check.length - 1){ check[0].checked = true; }else{ check[0].checked = false; }; }; });};","link":"/2019/05/28/ui-agree-checkbox/"},{"title":"Vue CLI 명령어(2.x)","text":"최소 뷰 기능만 들어간 HTML 파일 1개 생성$ vue init simple 고급 웹팩 기능을 활용한 프로젝트 구성 방식. 테스팅, 문법 검사 등을 지원$ vue init webpack 웹팩 최소 기능을 활용한 프로젝트 구성 방식. 빠른 화면 프로토타이밍용$ vue init webpack-simple 고급 브라우저파이 기능을 활용한 프로젝트 구성 방식. 테스팅, 문법 검사 등을 지원$ vue init browserify 브라우저파이 최소 기능을 활용한 프로젝트 구성 방식. 빠른 화면 프로토타이밍용$ vue init browserify-simple CLI 관련 라이브러리 설치$ npm install 웹팩 데브 서버 실행$ npm run dev","link":"/2019/07/01/vue-cli-command/"},{"title":"리눅스 명령어","text":"체크리눅스 버전체크 1# uname -a CentOS 버전체크 1# cat /etc/redhat-release 하드용량체크 1# df -h 디렉토리현재 디렉토리 확인하기 1# pwd 현재 디렉토리 목록 보기 1# ls 현재 디렉토리 목록 자세히 보기 1# ll 파일/폴더파일 생성 123# touch [파일명]# cat [파일명]# vi [파일명] 폴더 생성 1# mkdir [폴더명] vi 편집기 실행 1# vi [파일명] vi 편집기 저장 후 끝내기(ESC 누른뒤) 1# wq vi 편집기 저장하지 않고 끝내기(ESC 누른뒤) 1# q! 파일 삭제 1# rm [파일명] 파일 삭제 확인을 거치지 않고 삭제 1# rm -f [파일명] 해당 폴더 삭제 1# rm -r [폴더명] 폴더 삭제 확인을 거치지 않고 삭제 1# rm -rf [폴더명] 압축tar 압축하기 1234# tar -cvf [파일명.tar] [폴더명]ex) foo라는 폴더를 boo.tar로 압축하고자 한다면# tar -cvf boo.tar foo tar 압축 풀기 1234# tar -xvf [파일명.tar]ex) foo.tar라는 tar파일 압축을 풀고자 한다면# tar -xvf foo.tar tar.gz 압축하기 1234# tar -zcvf [파일명.tar.gz] [폴더명]ex) foo라는 폴더를 boo.tar.gz로 압축하고자 한다면# tar -zcvf boo.tar.gz foo tar.gz 압축 풀기 1234# tar -zxvf [파일명.tar.gz]ex) aaa.tar.gz라는 tar.gz파일 압축을 풀고자 한다면# tar -zxvf aaa.tar.gz MySQLMySQL 설치 유무 1# rpm -qa | grep mysql MySQL 설치 1# yum install mariadb MySQL 설치 경로 확인 1# find / -name mysql","link":"/2019/10/10/linux-command/"},{"title":"커스텀 셀렉트박스(custom selectbox)","text":"이번 프로모션에 커스텀이 필요한 셀렉트박스가 필요하여 제작하였다. 조건 셀렉트가 된 항목은 ‘selected’ 라는 클래스명이 붙는다. 항목이 많아질 경우 커스텀된 스크롤바가 생긴다(크롬에서만 적용). 생성자 함수방식 및 프로토타입에 메서드를 추가하여 재사용 및 메모리 관리에 용이하다. 구현 function CustomSelectBox(selector){ this.$selectBox = null, this.$select = null, this.$list = null, this.$listLi = null; CustomSelectBox.prototype.init = function(selector){ this.$selectBox = $(selector); this.$select = this.$selectBox.find('.box .select'); this.$list = this.$selectBox.find('.box .list'); this.$listLi = this.$list.children('li'); } CustomSelectBox.prototype.initEvent = function(e){ var that = this; this.$select.on('click', function(e){ that.listOn(); }); this.$listLi.on('click', function(e){ that.listSelect($(this)); }); $(document).on('click', function(e){ that.listOff($(e.target)); }); } CustomSelectBox.prototype.listOn = function(){ this.$selectBox.toggleClass('on'); if(this.$selectBox.hasClass('on')){ this.$list.css('display', 'block'); }else{ this.$list.css('display', 'none'); }; } CustomSelectBox.prototype.listSelect = function($target){ $target.addClass('selected').siblings('li').removeClass('selected'); this.$selectBox.removeClass('on'); this.$select.text($target.text()); this.$list.css('display', 'none'); } CustomSelectBox.prototype.listOff = function($target){ if(!$target.is(this.$select) && this.$selectBox.hasClass('on')){ this.$selectBox.removeClass('on'); this.$list.css('display', 'none'); }; } this.init(selector); this.initEvent(); } $(function(){ var select = new CustomSelectBox('.select_box'); }); .wrap * { margin: 0; padding: 0; } .wrap ul li, .wrap ol li { list-style: none; } .select_box { margin: 20px; } .select_box .box { display: inline-block; position: relative; width: 150px; } .select_box .box .select { position: relative; border: 2px solid #ccc; box-sizing: border-box; padding: 0 10px; width: 100%; height: 40px; line-height: 35px; font-size: 16px; background-color: #fff; cursor: pointer; } .select_box .box .select:after { content: '▼'; position: absolute; top: 7px; right: 10px; transform: none; border: 0; } .select_box.on .box .select:after { content: '▲'; } .select_box .box .list { display: none; overflow-y: auto; position: absolute; top: 45px; left: 0; z-index: 10; margin: 0; border: 2px solid #ccc; box-sizing: border-box; padding: 10px 0; width: 100%; max-height: 200px; background-color: #fff; } .select_box .box .list::-webkit-scrollbar { width: 10px; height: 0; } .select_box .box .list::-webkit-scrollbar-button:start:decrement, .select_box .box .list::-webkit-scrollbar-button:end:increment { display: block; height: 0; } .select_box .box .list::-webkit-scrollbar-track { background: rgba(0, 0, 0, .05); -webkit-border-radius: 10px; border-radius: 10px; } .select_box .box .list::-webkit-scrollbar-thumb { height: 50px; width: 50px; background: rgba(0, 0, 0, .2); -webkit-border-radius: 5px; border-radius: 5px; } .select_box .box .list>li { box-sizing: border-box; padding: 0 10px; width: 100%; height: 35px; line-height: 35px; cursor: pointer; } .select_box .box .list>li:hover { background-color: #ccc; } 선택 선택 항목01 항목02 항목03 항목04 항목05 항목06 항목07 항목08 항목09 항목10 HTML1234567891011121314151617181920&lt;div class=\"wrap\"&gt; &lt;div class=\"select_box\"&gt; &lt;div class=\"box\"&gt; &lt;div class=\"select\"&gt;선택&lt;/div&gt; &lt;ul class=\"list\"&gt; &lt;li class=\"selected\"&gt;선택&lt;/li&gt; &lt;li&gt;항목01&lt;/li&gt; &lt;li&gt;항목02&lt;/li&gt; &lt;li&gt;항목03&lt;/li&gt; &lt;li&gt;항목04&lt;/li&gt; &lt;li&gt;항목05&lt;/li&gt; &lt;li&gt;항목06&lt;/li&gt; &lt;li&gt;항목07&lt;/li&gt; &lt;li&gt;항목08&lt;/li&gt; &lt;li&gt;항목09&lt;/li&gt; &lt;li&gt;항목10&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182.wrap * { margin: 0; padding: 0;}.wrap ul li,.wrap ol li { list-style: none;}.select_box { margin: 20px;}.select_box .box { display: inline-block; position: relative; width: 150px;}.select_box .box .select { position: relative; border: 2px solid #ccc; box-sizing: border-box; padding: 0 10px; height: 40px; line-height: 35px; font-size: 16px; background-color: #fff; cursor: pointer;}.select_box .box .select:after { content: '▼'; position: absolute; top: 0; right: 10px;}.select_box.on .box .select:after { content: '▲';}.select_box .box .list { display: none; overflow-y: auto; position: absolute; top: 45px; left: 0; z-index: 10; border: 2px solid #ccc; box-sizing: border-box; padding: 10px 0; width: 100%; max-height: 200px; background-color: #fff;}.select_box .box .list::-webkit-scrollbar { width: 10px; height: 0;}.select_box .box .list::-webkit-scrollbar-button:start:decrement,.select_box .box .list::-webkit-scrollbar-button:end:increment { display: block; height: 0;}.select_box .box .list::-webkit-scrollbar-track { background: rgba(0, 0, 0, .05); -webkit-border-radius: 10px; border-radius: 10px;}.select_box .box .list::-webkit-scrollbar-thumb { height: 50px; width: 50px; background: rgba(0, 0, 0, .2); -webkit-border-radius: 5px; border-radius: 5px;}.select_box .box .list&gt;li { box-sizing: border-box; padding: 0 10px; width: 100%; height: 35px; line-height: 35px; cursor: pointer;}.select_box .box .list&gt;li:hover { background-color: #ccc;} javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546function CustomSelectBox(selector){ this.$selectBox = null, this.$select = null, this.$list = null, this.$listLi = null; CustomSelectBox.prototype.init = function(selector){ this.$selectBox = $(selector); this.$select = this.$selectBox.find('.box .select'); this.$list = this.$selectBox.find('.box .list'); this.$listLi = this.$list.children('li'); } CustomSelectBox.prototype.initEvent = function(e){ var that = this; this.$select.on('click', function(e){ that.listOn(); }); this.$listLi.on('click', function(e){ that.listSelect($(this)); }); $(document).on('click', function(e){ that.listOff($(e.target)); }); } CustomSelectBox.prototype.listOn = function(){ this.$selectBox.toggleClass('on'); if(this.$selectBox.hasClass('on')){ this.$list.css('display', 'block'); }else{ this.$list.css('display', 'none'); }; } CustomSelectBox.prototype.listSelect = function($target){ $target.addClass('selected').siblings('li').removeClass('selected'); this.$selectBox.removeClass('on'); this.$select.text($target.text()); this.$list.css('display', 'none'); } CustomSelectBox.prototype.listOff = function($target){ if(!$target.is(this.$select) &amp;&amp; this.$selectBox.hasClass('on')){ this.$selectBox.removeClass('on'); this.$list.css('display', 'none'); }; } this.init(selector); this.initEvent();} 인스턴스 생성123$(function(){ var select = new CustomSelectBox('.select_box');});","link":"/2019/10/02/ui-custom-selectbox/"},{"title":"웹 크롤링(Web Crawling)","text":"특정 데이터가 필요한 경우 Node.js를 이용하여 웹 크롤링을 하면 쉽게 데이터를 추출할 수 있다. 설치 환경 node.js npm 설치 모듈 request웹 페이지의 HTML문서를 그대로 가져오기 위한 모듈 cheerioHTML 문서를 파싱(parsing)하여 필요한 정보만을 가져올 수 있도록 도와주는 모듈, 제이쿼리 셀렉터를 사용할 수 있다. 작업 순서 원하는 디렉토리에 폴더 생성 후 js 파일 생성(crawling.js로 만들었음) 터미널에서 프로젝트 폴더로 진입 package 생성(이름만 설정한뒤 모두 예스)1&amp; npm init 필요 모듈 설치12$ npm install cheerio $ npm install request package.json 파일에 아래처럼 해당 모듈의 버전이 나타난다면 제대로 설치가 된 것이다. 1234\"dependencies\": { \"cheerio\": \"^1.0.0-rc.2\", \"request\": \"^2.83.0\"} 생성한 crawling.js 파일에 설치한 모듈을 불러준다. 12var cheerio = require('cheerio');var request = require('request'); url 변수에 파싱할 주소를 입력하고, request 모듈을 이용하여 웹페이지를 로드한다. 12345var url = 'http://www.naver.com';request(url, function(error, response, html){ var $ = cheerio.load(html); // 여기서 제이쿼리 셀렉터를 이용하여 원하는 정보를 가져올 수 있다.}); 아래는 전체 코드이다. 12345678910111213var cheerio = require('cheerio');var request = require('request');var url = 'http://www.naver.com';request(url, function(error, response, html){ var $ = cheerio.load(html); // 여기서 제이쿼리 셀렉터를 이용하여 원하는 정보를 가져올 수 있다. console.log($('.naver_logo').text());}); References Node.js로 멜론 순위 차트 데이터 파싱[Node.js] node.js환경에서 웹 크롤링 하기(cheerio-httpcli)[Node.js] 크롤링 DOM parsing ( request, cheerio, iconv 모듈 )","link":"/2019/08/20/web-crawling/"},{"title":"CentOS7 PHP 설치","text":"설치환경 CentOS 7.2 Extra Packages for Enterprise Linux (EPEL) repository CentOSCentOS는 리눅스(Linux) 계열의 배포판 버전, 리눅스 계열중에서도 레드햇(RedHat)계열이다.국내에서 웹 서버로 많이 사용하는 배포판이 센토스(Centos)와 우분투(Ubuntu)이다. Extra Packages for Enterprise Linux (EPEL) repositoryEPEL (Extra Packages for Enterprise Linux) 은 Fedora Project 에서 제공되는 저장소로 각종 패키지의 최신 버전을 제공하는 community 기반의 저장소이다. wget 설치인터넷에 있는 PHP압축파일을 설치하기 위해선 wget을 설치해야 한다. wget은 인터넷 파일을 다운받는 명령어로서 리눅스 최소 설치 시에는 wget을 따로 설치해야 한다. 아래 Yum 명령어를 이용하여 설치해 준다. YumYellow dog Updater, Modified의 약자로 RPM 기반의 시스템을 위한 자동 업데이터 겸 패키지 설치/제거 도구이다.이전에는 rpm으로 설치하였지만 Yum은 의존성을 고려하여 의존성 패키지까지 자동으로 설치된다. 1# yum install wget wget를 입력하였을 때 아래처럼 출력된다면 제대로 설치가 된 것이다. 1234wget: missing URLUsage: wget [OPTION]... [URL]...Try `wget --help' for more options. 1. remi repository를 yum 에 추가 한다. 123456# wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh epel-release-latest-7.noarch.rpm# wget http://rpms.remirepo.net/enterprise/remi-release-7.rpm# rpm -Uvh remi-release-7.rpm# yum install -y yum-utils# yum-config-manager --enable remi-php72 2. 기존의 설치된 PHP 패키지를 확인하여 잘못된 패키지가 삭제되지 않도록 한다. 1# yum list installed | cut -d &quot; &quot; -f 1 | grep php 3. 기존 설치된 PHP를 제거한다. 1# yum remove -y `yum list installed | cut -d &quot; &quot; -f 1 | grep php` 4. php 패키지 설치한다. php-common 외의 패키지는 자신의 상황에 맞게 조정해서 설치한다. 12345678# yum install -y php-common php-fpm php-cli \\ php-process \\ php-opcache php-pecl-apcu \\ php-mysqlnd php-pdo \\ php-gd \\ php-mbstring php-xml \\ php-pecl-zip \\ php-bcmath “php-common” 대신 “php72w-common”과 같이 PHP 버전을 지정한 패키지를 사용해도 된다. 항상 최신 버전을 사용할 것이 아니라 특정 버전대를 사용해야 한다면 이 방법을 사용하자. 향후 PHP가 버전업되면 운영중인 프로그램과의 호환에 문제가 발생할 수 있으므로 이 방법이 더 안전하다. 단, 메이저 버전업시 기존 패키지를 지우고 설치하는 방법을 사용해야 하므로 불편하다. 기존에 yum으로 설치된 PHP가 존재하고 해당 패키지의 이름이 “php-“로 시작한다면 기존 패키지를 지우고 재설치하는 것보다 아래처럼 그냥 update 받는 방법도 있다. 1# yum update php-* 5. 설치된 php 버전을 확인해 본다. 123456# php -vPHP 7.2.24 (cli) (built: Oct 22 2019 11:15:01) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies with Zend OPcache v7.2.24, Copyright (c) 1999-2018, by Zend Technologies References PHP 7.2 설치(업그레이드) [CentOS 7 / remi RPM repository]RHEL/CentOS 5,6,7 에 EPEL 과 Remi/WebTatic Repository 설치하기YUM 명령어와 epel 저장소 추가하는 방법","link":"/2019/10/24/centos-php-install/"},{"title":"CentOS7 Apache 설치","text":"yum을 이용하여 apache를 설치한다. 1# yum -y install httpd apache 버전을 확인하여 설치가 제대로 되었는지 확인해 본다. 1234# httpd -vServer version: Apache/2.4.6 (CentOS)Server built: Aug 8 2019 11:41:18 apache 실행CentOS7부터 기존에 사용하단 service 명령이 실행되지 않을 수 있다. systemctl 명령어를 사용해준다. 1# systemctl start httpd 부팅될 때 마다 apache를 실행 1# chkconfig httpd on 자신의 공인아이피로 들어가보면 apache 서버가 실행되어 있는 확인해 볼 수있다. 자신의 공인아이피를 확인하고 싶다면 curl를 확인해 볼 수 있다. # curl bot.whatismyipaddress.com# curl http://ipecho.net/plain# curl icanhazip.com# curl ipv4.icanhazip.com# curl ipv4.ipogre.com 이제 구동된 서버에 간단한 html 문서를 띄워보자. 아래 경로로 들어간다.(설치된 Apache 버전마다 경로가 다를 수 있다.) /var/www/html/ 해당 디렉토리로 가서 index.html 파일을 만들어준다. 1# touch index.html vi 편집기를 실행하여 “hello world!”를 입력하고 ESC를 누른뒤 아래 명령어를 입력하여 저장하고 나온다. 1# wq 공인아이피로 들어가 보면 “hello world!”가 제대로 출력되는 것을 확인할 수 있다. apache를 재시작할일이 드물기 때문에 종종 명령어를 잃어버린다. 아래 명령어를 참고하도록 한다. Apache 버전 확인# httpd -v Apache 상태 확인# systemctl status httpd# service httpd status Apache 시작# systemctl start httpd# service httpd start# apachectl start Apache 중지# systemctl stop httpd# service httpd stop# apachectl stop Apache 재시작# systemctl restart httpd# service httpd restart# apachectl restart References CentOS 아파치 설치CentOS에서 apache 설치CentOS 아파치 상태/재시작/시작/중지 명령어리눅스 공인 IP 확인","link":"/2019/10/25/centos-apache-install/"},{"title":"깃허브 블로그 SEO 세팅","text":"검색 엔진 최적화(Search Engine Optimization)검색엔진이 이해하기 쉽도록 홈페이지 구조를 설정하여 포털 사이트 상위에 노출시키는 작업이다. jekyll으로 제작된 깃허브 블로그에 SEO 작업을 진행하겠다. Sitemap 웹 크롤링 로봇이 이용할 수 있는 웹사이트의 접근 가능한 페이지의 목록 사이트맵을 등록하면 구글에서 주기적으로 크롤링을 한 뒤 관련 검색어로 검색 시 해당 사이트가 노출이 된다. sitemap.xml 파일을 사용하면 사이트 구조를 구글, 네이버, 다음 등 검색엔진에 손 쉽게 제출할 수 있다. 검색엔진에 크롤링해야하는 URL을 알려줌으로써 색인을 생성하는 방법과 색인을 생성하는 방법을 제어한다. Sitemap.xml 생성하기 원활한 작업을 위해 /root 디렉토리를 생성해 준다. sitemap.zip 파일을 다운받아 압축 풀고 /root 디렉토리에 넣어준다. 해당 파일을 커밋, 푸쉬 한다. 블로그 주소/sitemap.xml 에 들어가여 제대로 사이트맵이 등록되었는지 확인해 보자 홈페이지의 모든글의 정보를 담고있는 사이트맵이 출력되는 것을 알 수 있다. 추후에 블로그 포스팅을 푸쉬 하면 jekyll이 빌드하면서 사이트맵도 자동으로 갱신된다. 사이트 맵에서 특정글의 정보를 변경하고 싶으면 아래와 같이 특정 글의 설정 값을 변경해 주면 된다. changefreq를 너무 짧게 하면 빈번한 접속으로 안좋은 영향을 미칠수 있다고 한다. 설정이 없을때 default 값은 사이트맵에 정의되어 있다. 12345678layout: posttitle: &quot;제목&quot;date: 0000-00-00 12:00:00 lastmod : 0000-00-00 12:00:00sitemap : changefreq : daily priority : 1.0--- 참고로 /sitemap.xml을 실행했을 때 제대로 안나오는 경우가 있는데, 주소 링크에 특수문자가 들어간 경우이다. 깃허브 블로그의 경우 포스팅 파일명으로 링크가 생성되므로 포스팅 파일명은 특수문자 및 한글 사용을 안하도록 한다. RSS RSS(Rich Site Summary)란 뉴스나 블로그 사이트에서 주로 사용하는 콘텐츠 표현 방식이며, 웹 사이트 관리자는 RSS 형식으로 웹 사이트 내용을 보여 준다. RSS피드는 정기적으로 업데이트 되는 웹 콘텐츠를 전달해 주는 형태이며, 글의 전체 혹은 요약된 정보와 작성자 등의 정보가 포함되어 있다. 즉 블로그의 글을 작성하면 RSS피드에도 전달이 되고, 구글, 네이버, 다음 등을 통해 글을 검색하면, 검색 엔진은 블로그의 RSS피드로부터 글을 받게 되어 해당 블로그로 들어오게 된다. RSS feed.xml 생성하기 사이트맵과 동일하게 feed.zip을 다운받아 압축 풀어준 뒤 /root 디렉토리에 넣어준다. 해당 파일을 커밋, 푸쉬 하고 블로그 주소/feed.xml 에 제대로 등록되었는지 확인해 보자. robots.txtrobots.txt는 로봇 배제 표준을 따르는 일반 텍스트 파일이다. 쉽게 표현하면 검색 엔진이 해당 사이트의 콘텐츠를 가져가도 허락하는 부분과 가져가면 안된다 라는 설정을 하는 부분이라고 보면 된다. 위와 동일하게 /root 디렉토리에 위치한다. robots.txt 생성 robots.txt 파일을 만들고 아래와 같이 입력한다. 1234User-agent: *Allow: /Sitemap: https://recordboy.github.io/sitemap.xml User-agent는 허용할 검색엔진 명을 넣게 된다. 따로 설정하지 않으면(*) 모든 검색엔진을 허용하게 된다. Sitemap은 본인 블로그 사이트맵 주소를 넣어 주면 된다. 블로그 등록본인 블로그를 등록 해야 구글 및 네이버에서 검색이 가능하다. Google Search Console Google Search Console에 접속한다. SEARCH CONSOLE 버튼을 클릭한다. 속성 유형 선택화면이 나오면 URL 접두어 방식을 선택 후 해당 블로그 주소를 등록한다. 메타 태그를 이용한 사이트 소유권을 확인한 뒤 사이트맵을 등록해주면 된다. (여기에 설명이 참 잘 되어있다.) 구글 애널리틱스에 같은 계정으로 가입이 되어있으면 자동으로 소유 확인이 된다. Naver Webmaster 네이버 웹마스터 도구에 접속한다. 로그인하고 블로그 주소를 등록해 사이트를 추가해 준다. 웹마스터 도구에서 제공하는 html 파일을 다운받아 본인 블로그에 업로드하거나 메타태그를 이용하는 방법으로 사이트 소유권을 확인한다. 왼쪽 요청 메뉴로 들어가 사이트맵을 제출해준다. 깃허브에서 공식적으로 지원하는 jekyll블로그는 RSS2.0이 아닌, ATOM이라는 방식으로 feed.xml을 생산해준다. 그리고 ATOM방식으로 제작된 피드는 네이버 웹마스터도구에 등록이 안된다. References github blog를 google에서 검색되도록 설정하기구글(Google) 검색에 내 사이트 등록하기홈페이지 검색 잘 되도록 만들기RSS피드란?robots.txt 파일 만들기","link":"/2019/12/01/github-seo-setting/"},{"title":"Git Commit Message Convention","text":"커밋 메시지는 제목, 본문(선택), 꼬리말(선택) 세 부분으로 작성한다. 12345타입(Type): 제목(Title)본문(Body)꼬리말(Footer) 제목 커밋 메세지 제목의 맨 앞에 타입(Type)을 붙여준다. 각 타입의 종류는 아래와 같다. 기능(feat): 새로운 기능을 추가 버그(fix): 버그 수정 리팩토링(refactor): 코드 리팩토링 형식(style): 코드 형식, 정렬, 주석 등의 변경(동작에 영향을 주는 코드 변경 없음) 테스트(test): 테스트 추가, 테스트 리팩토링(제품 코드 수정 없음, 테스트 코드에 관련된 모든 변경에 해당) 문서(docs): 문서 수정(제품 코드 수정 없음) 기타(chore): 빌드 업무 수정, 패키지 매니저 설정 등 위에 해당되지 않는 모든 변경(제품 코드 수정 없음) 총 글자 수는 50자 이내며 마지막에 마침표(.)를 붙이지 않는다. 커밋 유형들이 복합적인 경우 최대한 분리하여 커밋한다. 본문 본문은 한 줄당 72자 이하로 작성한다. 깃은 자동 줄바꿈을 지원하지 않으므로, 직접 줄바꿈을 해야 한다. 내용은 어떻게 변경하였는지 보다 무엇을, 왜 변경하였는지 설명한다. 꼬리말 바닥 글은 선택 사항이며 이슈 트래커 ID를 참조하는데 사용된다. References Git 사용 규칙 - Git commit 메시지Udacity Git Commit Message Style Guide깃허브(GitHub)로 취업하기How to Write a Git Commit Message좋은 git 커밋 메시지를 작성하기 위한 7가지 약속","link":"/2019/11/01/git-commit-message-convention/"},{"title":"CentOS7 영카트 설치 및 초기 세팅","text":"초기 설치 환경 CentOS 7 사용자 설정로그인 12login as: rootpassword: 최초 세팅된 PW 입력 새 PW 입력 1# passwd webapp 계정 생성 및 새 PW 입력 12# useradd '새 계정 ID'# passwd '새 계정 ID' ssh root 접속 제한 위해 sshd_config 실행 12# vi /etc/ssh/sshd_config# PermitRootLogin yes 에서 no 로 변경 후 저장 ssh 재시작 1# systemctl restart sshd root ssh 접속 되는지 확인 후 webapp으로 접속 후 root로 변경 1# su root Nginx 설치패키기 업그레이드 12# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm Nginx 설치 1# yum install nginx.x86_64 Nginx 활성화 12# systemctl start nginx# systemctl enable nginx 본인 ip주소로 들어가 CentOS 화면이 출력되면 성공 MySQL 설치wget 설치 1# yum install wget MySQL 다운로드 1# wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm MySQL 5.7 설치 1# sudo rpm -ivh mysql57-community-release-el7-11.noarch.rpm MySQL 5.7 서버 설치 1# sudo yum install mysql-server MySQL 5.7 데몬 시작 1# sudo systemctl start mysqld 비밀번호 설정MySQL 접속 1# mysql -u root -p 패스워드 변경(중요! MySQL 5.7 이후부터 대문자, 숫자, 특수문자 포함된 12자리 이상의 패스워드만 통과한다.) 123# UPDATE mysql.user SET authentication_string = PASSWORD('패스워드 입력') WHERE User = 'root' AND Host = 'localhost';# FLUSH PRIVILEGES;# exit 만약 로그인이 제대로 되지 않는 경우 1234567# systemctl stop mysqld# systemctl set-environment MYSQLD_OPTS=&quot;--skip-grant-tables&quot;# systemctl start mysqld# mysql -u root // root 계정 비번 없이 접속 가능# UPDATE mysql.user SET authentication_string = PASSWORD('여기에 새로운 비밀번호 입력') WHERE User = 'root' AND Host = 'localhost';# FLUSH PRIVILEGES;# exit 아래와 같은 오류가 뜰 경우You must reset your password using ALTER USER statement before executing this statement. ALTER USER 문을 사용하여 비밀번호 재설정 1# ALTER USER 'root'@'localhost' IDENTIFIED BY '여기에 새로운 비밀번호 입력'; 비밀번호 validation이 까다로우니, 이것을 없애기 위한 설정 12# mysql -u root -p# uninstall plugin validate_password; 데이터베이스 생성1# create database DB 이름; 데이터베이스 확인 1# show databases; 사용자 추가 &amp; 권한 부여(root 로 mysql 접속 후 작업)localhost 로만 접근 가능한 계정 생성(외부에서 워크벤치 등으로 접근 안됨) 1# create user '새로 만들 사용자 ID'@'localhost' identified by '새로운 사용자의 비밀번호'; 외부에서 워크벤치 등으로 접근 가능한 계정 생성 1# create user '새로 만들 사용자 ID'@'%' identified by '새로운 사용자의 비밀번호'; 해당 계정에 해당 데이터베이스의 모든 권한 부여 1# grant all privileges on 'DB 이름'.* to '사용자 ID'@'%'; 해당 계정에 데이터베이스의 모든 권한 부여 1# grant all privileges on *.* to '사용자 ID'@'%'; 해당 계정에 데이터베이스의 모든 권한 부여하고 비번 변경 1# grant all privileges on *.* to '사용자 ID'@'%' identified by '새로운 비밀번호'; 적용후에는 아래 명령어를 꼭 실행 해줘야 한다. 1# FLUSH PRIVILEGES; 외부 접속 설정 (firewall)123# yum install firewalld# systemctl start firewalld# systemctl enable firewalld 서비스 재구동시에는 # firewall-cmd --reload 명령 사용public은 zone 이름이며, 클라우드 시스템처럼 zone 형태로 방화벽 포트들을 관리할수 있음 1# firewall-cmd --permanent --zone=public --add-port=3306/tcp 포트를 범위로 지정하기 1# firewall-cmd --permanent --zone=public --add-port=5000-5100/tcp 포트 삭제 1# firewall-cmd --permanent --zone=public --remove-port=3306/tcp 모든 접속을 허용하고 싶을때(방화벽을 내리지 않고, zone을 trusted로 변경) 1# firewall-cmd --set-default-zone=trusted PHP 설치12345678910111213# yum install yum-plugin-replace# yum install mod_php71w php71w-common# yum install php71w-gd# yum install php71w-fpm# yum install php71w-opcache# yum install php71w-cli# yum install php71w-mysqlnd# yum install php71w-xml# yum install php71w-mbstring# sed -i 's/;date.timezone =/date.timezone = Asia\\/Seoul/g' /etc/php.ini# yum install -y make automake gcc gcc-c++ kernel-devel openssl-devel php php-devel php-pear bzip2-devel libvpx-devel yum-utils bison re2c libmcrypt-devel libpqxx-devel libxslt-devel pcre-devel libcurl-devel libgsasl-devel openldap-devel libmemcached-devel libjpeg-devel libpng-devel readline-devel PHP 활성화 12# systemctl start php-fpm# systemctl enable php-fpm vi /etc/php-fpm.d/www.conf로 들어가서 group = apache를 group = webapp으로 변경, user = apache도 user = webapp 로 변경 필수하드웨어 사양에 따라 pm 관련 세팅 환경 설정nginx conf 파일 세팅 1# vi /etc/nginx/conf.d/www.domain.co.kr.conf 아래와 동일하게 수정한 뒤 server_name 을 본인 IP에 맞게 입력 하고 저장 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051server { listen 80; server_name 00.000.000.000; access_log /var/log/nginx/$host.access.log main; error_log /var/log/nginx/$host.error.log; root /data/web_htdocs; index index.php; client_max_body_size 200M; sendfile on; # Deny dotfiles (**/.*) location ~ /\\. { deny all; } # Deny .php (**/*.php) location ~ \\.php$ { rewrite ^.* /index.php; }location / { index index.php index.html index.htm; try_files $uri $uri/ /index.php?$query_string; error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root /data/web_htdocs; } location ~ \\.php$ { root /data/web_htdocs; try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_buffer_size 128k; fastcgi_buffers 256 16k; fastcgi_busy_buffers_size 256k; fastcgi_temp_file_write_size 256k; include fastcgi_params; } location ~ /\\.ht { deny all; } }} 디렉토리 세팅 및 권한 설정을 위해 data 및 web_htdocs 폴더를 만들어 준다. 12# mkdir /data# mkdir /data/web_htdocs data폴더의 파일 권한과 소유권을 변경해준다. 12# chmod -R 777 /data# chown -R webapp:webapp /data FTP로 youngcart5.tar.gz를 /data/web_htdocs에 업로드 후 압축을 푼다. 123# cd /data/web_htdocs# tar xvfz youngcart5.tar.gz# systemctl restart nginx 본인 아이피주소로 들어가 사용자 정보를 입력하면 자동으로 설치가 완료된다. References MySQL 5.7 세팅 (CentOS7)","link":"/2019/12/10/centos-youngcart-init/"},{"title":"입력 서식 관련 접근성(Information Accessibility Technology Conference)","text":"2019년 11월 22일 정보접근성 기술 컨퍼런스를 다녀온뒤 세미나 내용을 정리 및 입력 서식 관련 접근성 대비에 관련한 내용이다. 입력 서식 관련 접근성1. 레이블이 시각적으로 노출된 경우&lt;label&gt;에 for와 &lt;input&gt;의 id를 동일하게 맞추어 준다. &lt;label&gt;을 클릭하면 해당 폼으로 커서가 이동한다. HTML 12&lt;label for=\"usr_id\"&gt;아이디&lt;/label&gt;&lt;input type=\"text\" id=\"usr_id\" /&gt; 결과 아이디 2. 레이블이 시각적으로 노출되지 않은 경우&lt;input&gt;태그만 있는 경우는 title속성을 꼭 명시하여 스크린 리더기가 인식할 수 있도록 한다. HTML 1&lt;input type=\"text\" id=\"usr_id\" title=\"아이디\" /&gt; 스크린 리더기 소리: “아이디 편집 창” 3. 읽기 전용 편집 창인 경우title속성을 넣어주지 않으면 해당 편집 창의 제목을 건너 띄고 결과값만 읽는다. 꼭 title속성을 써주도록 한다. HTML 1&lt;input type=\"text\" readonly=\"readonly\" value=\"25\" /&gt; 스크린 리더기 소리: “25 읽기전용 편집 창” 1&lt;input type=\"text\" readonly=\"readonly\" value=\"25\" title=\"나이\" /&gt; 스크린 리더기 소리: “나이 25 읽기전용 편집 창” 4. placeholder가 있는 경우placeholder는 보조 수단으로 레이블 대체가 불가능하다. 이 역시 title속성을 꼭 넣어주도록 한다. HTML 1&lt;input type=\"text\" placeholder=\"user@naver.com\" /&gt; 스크린 리더기 소리: “user@naver.com 편집 창” 1&lt;input type=\"text\" placeholder=\"user@naver.com\" title=\"이메일\" /&gt; 스크린 리더기 소리: “이메일 편집 창” 5. 다수의 입력 서식이 존재하는 경우title속성에 입력 내용 및 자리수까지 상세히 명시한다. HTML 123&lt;input type=\"text\" placeholder=\"년(4자)\" title=\"태어난 년도 4자리\" /&gt;&lt;input type=\"text\" placeholder=\"월\" title=\"태어난 월\" /&gt;&lt;input type=\"text\" placeholder=\"일\" title=\"태어난 일\" /&gt; 6. id, for가 명시되어 있지 않고 암묵적 레이블로 제공하는 경우최신 버전의 스크린 리더기는 암묵적 레이블을 읽어 주긴 하지만 역시 많은 스크린 리더기 사용에 문제가 발생하고 있어 꼭 명시적으로 레이블을 사용하기를 권장하고 있다. HTML1234&lt;label&gt; 아이디 &lt;input type=\"text\"&gt;&lt;/label&gt; 스크린 리더기 소리: “아이디 편집 창” 7. 커스터마이징이 되어 있는 경우커스터마이징이 되어있는 입력서식의 경우 키보드를 이용한 조작이 필수며, 마크업 형태는 기본서식과 동일하도록 권장하고 있다.(예: 라디오 버튼의 경우 키보드 좌, 우 버튼으로 조작 가능)복잡한 입력서식의 경우 아리아로 구현이 가능하지만 느리다는 단점이 있다. 접근성 교육 및 솔루션부스트코스 웹 접근성 강의웹 접근성 이해라는 사이트에서 웹 접근성 강의를 보다 쉽게 배울 수 있다. References 웹 접근성 이해레진 웹 접근성 가이드라인","link":"/2019/12/04/iat-conference-form/"},{"title":"웹 접근성 정의 및 대비 방법(Information Accessibility Technology Conference)","text":"2019년 11월 22일 정보접근성 기술 컨퍼런스를 다녀온뒤 세미나 내용을 정리 및 웹 접근성에 대해 작성한 글이다. 웹 접근성이란?웹 접근성(Web Accessibility) 이란 장애인, 고령자 등이 웹 사이트에서 제공하는 정보에 비장애인과 동등하게 접근하고 이해할 수 있도록 보장하는 것이다. 법으로는 2017년 7월 26일부터 장애인차별금지법으로 시행되었다. 장애인 차별금지 및 권리구제 등에 관한 법률제 2조(장애와 장애인) 이 법에서 금지하는 차별행위의 사유가 되는 장애라 함은 신처적, 정신적 손상 또는 기능상실이 장기간에 걸쳐 개인의 일상 또는 사회생활에 상당한 제약을 초래하는 상태를 말한다. 장애인이라 함은 제1항에 따른 장애가 있는 사람을 말한다. 웹 접근성은 정보와 사용자의 디지털정보격차를 줄인다는 개념으로도 볼 수 있다. 디지털정보격차(Digital Divide)란? 정보통신기술에서의 접근, 역량, 활용에 있어서의 불평등 사회자원에서의 접근, 역량, 활용에 있어서의 불평등 또한 접근성에서의 ‘장애’는 개인의 건강상태가 아니라 인간 상호작용이 일치하지 않는 상황으로 볼 수 있고, 접근성은 아래와 같은 의미로도 해석할 수 있다. 각자 다른 능력을 가진 사람들이 모든 것을 경험할 수 있도록 가능성을 만들어 주는것 그리고 이를 달성하기 위해 전문가들이 노력하는 것 정보통신 환경의 장애유형과 보완대책 장애유형 특징 보완대책 시각장애(전맹) 모니터를 볼 수 없음 스크린리더 시각장애(저시력) 모니터 사용이 일부 가능함 화면확대/고대비 시각장애(색맹) 색을 구별할 수 없음 색상에만 의존하지 않기/고대비 청각장애 사운드, 오디오 등을 창취할 수 없음 수화, 시각정보 제공 지체장애(상지장애) 손을 사용할 수 없음 마우스 대체 방법, 키보드만 사용 지체장애(기타) 움직임이 어려움 충분한 시간 제공 언어장애 복잡한 용어, 어려운 용어의 이해 불가능 쉬운 용어 사용 웹 접근성 국제표준 검사항목(KWCAG)웹 접근성 한국표준이며 가이드는 한국형 웹 콘텐츠 접근성 지침 2.1 에서 확인해 볼 수 있다. 항목은 24가지 이며 국제표준(WCAG)은 더욱 엄격하여 항목으로는 78가지가 있다. 인식의 용이성 - 사람은 콘텐츠를 보거나 들을 수 있다. 적정한 대체 텍스트 텍스트 아닌 콘텐츠는 대체 가능한 텍스트와 함께 제공되어야 한다. 자막, 수화 등의 제공 영상이나 음성 콘텐츠에는 동등한 내용의 자막, 원고 또는 수화가 제공되어야 한다. 색에 무관한 콘텐츠 인식 화면에 표시되는 모든 정보는 색에 관계없이 인식될 수 있어야 한다. 명확한 지시사항 제공 특정한 감각(시각, 청각 등)에 의존하여 지시사항을 제공할 경우 해당 감각에 장애가 있다면 인식할 수 없으므로, 다른 감각을 통해서도 인식할 수 있도록 지시사항을 제공해야 한다. (3, 4번 항목의 예: 콘텐츠 구분 접근성) 텍스트 콘텐츠 명도 대비 화면에 표시되는 모든 사용자 인터페이스 컴포넌트와 텍스트는 전경색과 배경색이 구분될 수 있도록 제공되어야 한다.(예: 명도 대비 접근성) 자동 재생 금지 자동으로 재생되는 배경음을 사용하지 않아야 한다. 구글은 사용자가 원치 않은 미디어가 자동 재생되면서 데이터와 전력을 소모하고, 웹 탐색 중 소음을 유발한다는 이유로 2018년 1월부터 크롬 브라우저는 웹 사이트에서 자동으로 재생되는 영상을 기본 설정에서 차단한 사례가 있다. 콘텐츠 간의 구분 이웃한 콘텐츠는 구별될 수 있어야 한다. 운용의 용이성 - 사람이 타이핑이나 음성으로 컴퓨터를 사용할 수 있다. 키보드 사용 보장 모든 기능은 키보드만으로도 사용할 수 있어야 한다. 초점 이동 키보드의 Tab키(다음으로 이동)와 Shift + Tab(이전으로 이동)키로 확인해볼 수 있다. 초점 이동 순서가 순환적이며, 반복적이어야 한다. 페이지에 포함된 모든 링크, 버튼, 입력창에 초점이 가야한다. 사용자가 사용할 수 없는 비활성 요소(버튼, 입력창 등)에는 초점이 가지 않아야 한다. 조작 가능 손떨림이 심하여 미세한 조작이 어려운 경우와 같이 운동 장애가 있는 경우에도 사용자 입력 및 컨트롤은 조작이 가능하도록 제공되어야 한다. 응답시간 조절 웹 콘텐츠 제작 시 시간제한이 있는 콘텐츠는 가급적 포함하지 않는 것이 바람직하며, 보안 등의 사유로 시간제한이 반드시 필요할 경우에는 이를 회피할 수 있는 수단을 제공해야 한다.(일시 정지 등) 정지기능 제공 자동으로 변경되는 콘텐츠는 움직임을 제어할 수 있어야 한다. 깜빡임과 번쩍임 사용 제한 초당 3~50회 주기로 깜빡이거나 번쩍이는 콘텐츠를 제공하지 않아야 한다. 반복영역 건너뛰기 콘텐츠의 반복되는 영역은 건너뛸 수 있어야 한다.(스킵 네비게이션) 제목 제공 페이지, 프레임, 콘텐츠 블록에는 적절한 제목(헤딩 태그)을 제공해야 한다. 적절한 링크 텍스트 링크 텍스트는 용도나 목적을 이해할 수 있도록 제공해야 한다.(새창 열림 및 더보기) 이해의 용이성 - 사람이 명확하고 단순한 언어로 사용할 수 있다. 기본언어 표시 주로 사용하는 언어를 명시해야 한다. 웹 페이지에 주로 사용하는 언어를 &lt;html&gt; 요소에 lang 속성을 지정하여 명시 사용자 요구에 따른 실행 사용자가 의도하지 않은 기능(새 창, 초점 변화 등)은 실행되지 않아야 한다. 콘텐츠 선형구조 콘텐츠는 논리적인 순서로 제공해야 한다. 콘텐츠 및 마크업이 논리적인 순서로 구성해야 한다. 표의 구성 표는 이해하기 쉽게 구성 및 caption 및 scope을 꼭 명시해 준다. 복잡한 표의 경우 id, header 를 사용한다. 레이블 제공 입력 서식에는 대응하는 레이블을 제공해야 한다. 오류정정 입력 오류를 정정할 방법을 제공해야 한다. 견고성 - 사람들이 다른 보조 기술을 사용할 수 있다. 마크업 오류 방지 마크업 언어의 요소는 열고 닫음, 중첩 관계 및 속성 선언에 오류가 없어야 한다. 웹어플리케이션 접근성 준수 콘텐츠에 포함된 웹 애플리케이션은 접근성이 있어야 한다. 대비해야 할 대표 기술 8가지1. 시멘틱 마크업W3C는 텍스트를 시각적으로 표현하는 태그보다 프로그램적으로 의미를 전달할 수 있는 시멘틱 마크업 사용을 권장한다. 웹 사이트는 결론적으로 ‘웹으로 된 문서’이기 때문이다. 예시 보통 아이콘을 &lt;i&gt; 태그를 사용하지만 이 태그는 이태릭체를 의미하는 태그이다. 아이콘으로 쓰지 말도록 하자. 의미가 없는 태그는 가상선택자(:after, :before)를 이용하며, 의미가 있는 태그는 &lt;span&gt; 태그 등에 대체 텍스트를 활용해 준다. &lt;b&gt; 태그는 강조보단 두껍게를 의미하는 태그이다. &lt;i&gt; 태그와 마찬가지로 사용을 지양하며, 강조의 의미인 &lt;strong&gt; 및 &lt;em&gt; 태그를 사용하도록 하자. 쇼핑몰 사이트의 10,000원 이런 형태의 가격표를 많이 보았을 것이다. 이 경우 &lt;del&gt; 태그를 사용하면 스크린리더기가 10,000원 뒤에 ‘삭제’ 라고 읽어준다. 이런식으로 의미론적인 태그를 사용하여 마크업을 작성하도록 하자. 2. 텍스트를 포함하는 이미지W3C는 특별한 경우를 제외하고는 텍스트를 이미지 형태로 제공하지 않도록 권장한다.텍스트 이미지는 사용자의 요구사항에 따라 시각적으로 사용자 정의될 수 있어야 한다. 예를 하나 들면 번역을 해야 되는 경우가 있다. 꼭 이미지로 사용해야 하는 경우에는 대체 텍스트를 꼭 사용해주도록 한다.(alt 속성 등) 3. 텍스트 명도대비W3C는 기본적으로 텍스트와 배경과의 명도대비는 최소한 4.5 : 1 을 제공하도록 권장한다. 대신 비활성 상태의 인터페이스 요소나 텍스트, 순수한 장식, 로고 또는 상표명에 포함된 텍스트의 경우, 그림의 일부인 텍스트의 경우 어떠한 명도대비 요구사항도 없다. 명도 대비 검사는 Contrast Finder에서 테스트해볼 수 있다. 4. 비 텍스트 명도대비W3C는 UI요소 및 그래픽 콘텐츠에 한에서 명도대비를 3:1을 제공하도록 권장하고 있다. 예를들어 그래프의 경우 명도가 비슷한 색 끼리 맞닿은 경우 닿는면 사이를 흰색 라인으로 처리를 해준다. 색애 무관한 콘텐츠 인식에서 예시를 확인할 수 있다. 5. WAI-ARIA정적인 HTML과 단순한 JavaScript 환경이 아닌 동적인 JavaScript 및 Ajax와 같은 기술을 사용한 환경에서 스크린리더 및 보조기기등이 접근성 및 상호 운용성을 향상시키기 위하여 탄생되었으며, 역할(Role), 속성(Property), 상태(State) 정보를 추가하여 이를 개선 할 수 있도록 제공하고 있다. W3C가 권장을 하고 있지만, 느리다는 단점이 있다. 6. 반응형 웹콘텐츠는 정보 또는 기능 손실 없이, 2차원 스크롤 없이 제공해야 한다. 2차원 스크롤을 이용해 본 사람은 알겠지만 콘텐츠 이용이 상당히 불편하다. 2차원 스크롤은 아래을 의미한다. 가로 320px 넓이에서 가로 스크롤이 없이 수직으로 스크롤 세로 256px 높이에서 세로 스크롤이 없이 수평으로 스크롤 7. 동영상 실시간 자막동영상 제공 시 W3C는 특별한 경우를 제외하고 동기화된 자막을 제공하도록 권장한다. 단, 미디어가 텍스트에 대한 대체수단이 분명히 명시된 경우는 예외이다. 되도록이면 대화, 해설, 효과음 등의 자막 스타일을 다르게 하여 나타내는 것도 하나의 방법이다. 동영상 자막의 경우 게임 분야가 상당히 잘 되어있다. 청각 장애와 난청을 위한 게임 만들기에서 좋은 예시를 볼 수 있다. 8. 자동완성기능입력칸의 목적성을 규정하여 각각의 입력 필드가 가지는 의미는 계획하에 결정되어야 한다. 다른 말로 하면, 사용자들로부터 어떤 값들이 입력되길 기대하는지, 혹은 입력된 정보의 의미가 무엇인지를 나타내는 코드가 필요하다. 이를 정확하게 하면 사용자의 브라우저가 이전에 사용자가 입력한 데이터들을 활용하여 미리 해당 입력 필드를 자동적으로 채우는 것을 가능하게 해준다. 결론기술이 필요한 궁극적인 이유는 사람이다. 정보 접근성 준수 기술은 사용자를 이해하고 배려하는 것에서 시작된다. 웹 접근성을 꼭 준수하도록 하자 References 네이버 접근성 가이드다음 접근성 가이드웹 접근성이란?웹 접근성의 이해장애인차별금지 및 권리구제 등에 관한 법률한국형 웹 콘텐츠 접근성 지침 2.1[인식의 용이성] 1.3.1. 색에 무관한 콘텐츠 인식[웹표준]WCAG 2.1 가이드라인한국웹접근성성인인증평가원","link":"/2019/12/03/iat-conference-web/"},{"title":"이미지 캐싱","text":"웹사이트의 이미지가 변경된 경우 캐쉬가 남아있어 변경사항이 적용안되는 경우가 있다.이럴경우 강력 새로고침을 해주면 적용이 된다. 새로고침 : f5 ctrl + f5 : 강력 새로고침 shift + f5 : 강력 새로고침(크롬) shift + ctrl + r : 강력 새로고침(크롬) 하지만 수정이 빈번한 프로젝트의 경우 매번 캐쉬를 지우고 그러기에는 사용자 입장에서 썩 좋은 방법은 아니다.몇가지 방법이 있는데 수정이 될때마다 이미지명을 버전별로 바꾸는 것이다. 변경 전 : “img.png” 변경 후 : “img_v01.png” 브라우저는 이미지명이 다를경우 다른 이미지라고 인식하여 불러오기 때문인데, 위 방법은 수정사항이 잦아질 경우 리소스 관리가 까다롭기 때문에 그렇게 좋은 방법은 아니다.조금 더 효율적인 방법은 이미지를 불러오는 경로 마지막에 파라미터를 추가하는 방법을 사용하면 된다. 변경 전 : “img.png” 변경 후 : “img.png?ver=1.0”","link":"/2019/10/17/img-caching/"},{"title":"디바이스 구분 스크립트","text":"어떤 디바이스로 접속했는지 확인 가능한 코드 12345678var filter = \"win16|win32|win64|macintel|mac|\"; // PC일 경우 가능한 값if(navigator.platform){ if(filter.indexOf(navigator.platform.toLowerCase()) &lt; 0){ alert(\"모바일에서 접속하셨습니다\"); }else{ alert(\"PC에서 접속하셨습니다\"); };};","link":"/2019/11/18/javascript-device-classification/"},{"title":"APM(Apache, Mysql, PHP)","text":"웹서버 구축을 하기위해 APM(Apache, Mysql, PHP) 3개의 패키지가 설치되어야 한다. Apache아파치는 Apache Software Foundation에서 개발한 HTTP 웹서버로서 프리 소프트웨어로 누구든지 수정, 재배포 등이 가능하고 오픈소스 프로그램이다. Linux, Unix, Windows, FreeBSD, Mac OS X 등과 같은 거의 모든 운영 체제에서 설치 및 사용이 가능하다. 웹서버는 크게 아파치/톰캣 과 IIS 로 나뉘게 된다. 아파치/톰캣은 프리소프트웨어에 오픈소스이고 IIS 는 MS사에서 제공하는 웹서버로서 MS사로부터 양질의 지원을 받을 수 있다. MysqlMySQL은 DBMS의 종류중 하나로서 전세계적으로 가장 널리 사용되고 있는 오픈 소스 데이터베이스(DataBase)이다. 제작사는 MySQL AB이다. PHPPHP는 웹서버쪽에서 실행 되는 스크립트 언어로서 주로 HTML 코드를 프로그래밍적으로 생성한다. 장점으로는 빠른 생산성, 저렴한 유지비용, 거의 모든 운영 체제에 구현이 가능하다.","link":"/2019/10/21/linux-apm/"},{"title":"리눅스 서버 세팅","text":"목적 가상 호스팅을 설정하여 자신의 웹서버로 이용 IWINV 서비스를 이용하여 리눅스 서버를 구매 리눅스 운영체제의 특징 리누스 토발즈가 개발한 컴퓨터 운영체제의 한 종류이며 커널 자체를 의미 자유 라이센스와 오픈 소스 개발의 가장 유명한 표본 다중 스레드를 지원하는 네트워크 운영 체제(NOS)로, 여러 사람이 하나의 리눅스 시스템에 접속하여 다수의 프로그램을 동시에 실행할 수 있다. MS에서 개발된 MSSQL을 제외한 대부분의 DB를 지원 IWINV 서버 신청IWINV 서버 신청 가이드를 참조 https://www.iwinv.kr로 접속해 회원가입 관리 콘솔로 들어가 서버 선택 가상서버와 물리서버로 상품이 있으며 가상서버는 [Real Core 서버], [vCore 서버] 나누어 짐 논리적인 머신이냐, 물리적인 머신이냐에 따른 분류 이며 vCore &gt;&gt; Real Core &gt;&gt; RealServer 순으로 사양 이 높아 진다. 스탭 별로 필요한 옵션을 선택(아래는 필자가 선택한 옵션) Step01. ZONE 선택 &gt;&gt; KR1-Lite-Z01 Step02. 운영체제 선택 &gt;&gt; CentOS 7.X(64bit) Step03. 하드웨어 선택 &gt;&gt; SINGLE SSD &gt;&gt; vCore.V1-Lite Step04. 블록 스토리지 추가 &gt;&gt; 건너뛰기(데이터 손실을 방지하기 위해 블록 스토리지에 백업하는 서비스라 추정된다) Step05. 이름 설정 &gt;&gt; recordboy Step06. 수량 선택 &gt;&gt; 1개 Step07. 확인 서버 접속대부분의 리눅스 웹 서버는 SSH라는 터미널 프로그램에 접속 명령어를 직접 입력하면서 관리를 한다. 이번에 신청한 서버도 리눅스 서버 호스팅 상품이며, SSH접속정보만이 제공 된다.SSH 접속 프로그램은 PuTTY라는 프로그램을 쓸 것이다. SSH클라이언트란? SSH 접속을 지원하는 서버에 접속하기 위한 사용자 프로그램 PuTTY 사이트에 접속해 해당 프로그램 설치 프로그램 실행 후 Host Name(or IP address)란에 IWINV서버의 IP주소를 입력하고, 포트(22), 프로토콜(SSH)를 선택하여 접속한다. 본인의 IWINV 로그인 비밀번호를 이용해, 관리자(root) ID 로 로그인 한다. 비밀번호 인증이 성공하면 쉘 프롬프트가 떨어지며, #기호가 표시된다. root 가 아닌 일반 사용자일 경우에는 #기호 대신 $기호로 표시된다. SSH 접속 비밀번호는 Console 을 통한 시스템 로그인 비밀번호와 동일하다. root 계정은 Linux 시스템 내에서 최고 권한의 관리자 계정이므로, 비밀번호 보안에 각별한 주의를기울여야 한다. 초기 비밀번호가 복잡하니 아래 명령어로 패스워드를 변경해 준다.1$ passwd 해당 서버의 이름을 설정해 주자. 처음에는 root@서버이름: ~]# 식으로 보여진다. References 한번에 끝내는 CentOS 웹서버세팅 (센토스 서버세팅)IWINV 서버 신청 가이드Yum - 위키백과[리눅스 서버 구축하기] 1. 기초 지식 알아보기","link":"/2019/10/21/linux-server-init/"},{"title":"리눅스 MySQL 시작, 정지, 재시작, 상태확인","text":"리눅스 MySQL 시작, 정지, 재시작, 상태확인 작업 우분투 명령어 CentOS6 명령어 CentOS7 명령어 시작 # service mysql start # service mysqld start # systemctl start mysqld 정지 # service mysql stop # service mysqld stop # systemctl stop mysqld 재시작 # service mysql restart # service mysqld restart # systemctl restart mysqld 상태확인 # service mysql status # service mysqld status # systemctl status mysqld References 리눅스 MySQL 시작, 정지, 재시작, 상태확인","link":"/2019/12/12/linux-mysql-status-command/"},{"title":"Yum 명령어","text":"패키지 설치# install [패키지명] 패키지 삭제# yum remove [패키지명] 패키지 업데이트# yum update [패키지명] 패키지 정보 확인# yum info [패키지명] 패키지 검색# yum search [검색어] 패키지 목록 보기# yum list 설치된 패키지 목록 보기# yum list installed 패키지 설치, 변경, 삭제로 변경된 정보 보기# yum history list 저장소 확인하기# yum repolist","link":"/2019/10/23/linux-yum-command/"},{"title":"Nginx 기본 세팅","text":"Nginx 설치12345# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm# yum install nginx.x86_64# systemctl start nginx# systemctl enable nginx PHP 설치12345678910111213141516# yum install yum-plugin-replace# yum install mod_php71w php71w-common# yum install php71w-gd# yum install php71w-fpm# yum install php71w-opcache# yum install php71w-cli# yum install php71w-mysqlnd# yum install php71w-xml# yum install php71w-mbstring# sed -i 's/;date.timezone =/date.timezone = Asia\\/Seoul/g' /etc/php.ini# yum install -y make automake gcc gcc-c++ kernel-devel openssl-devel php php-devel php-pear bzip2-devel libvpx-devel yum-utils bison re2c libmcrypt-devel libpqxx-devel libxslt-devel pcre-devel libcurl-devel libgsasl-devel openldap-devel libmemcached-devel libjpeg-devel libpng-devel readline-devel# systemctl start php-fpm# systemctl enable php-fpm nginx.conf 파일찾기 1# sudo find / -name nginx.conf nginx.conf 수정하기 1# vi /etc/nginx/nginx.conf nginx 다시 로드 하기 1# sudo service nginx reload","link":"/2019/11/19/nginx-install/"},{"title":"포트(Port)","text":"포트(Port) 컴퓨터의 주변 장치와 연결하기 위한 연결단 IP 내에서 프로세스 구분을 하기 위해 사용 쉽게 말해 각 프로토콜의 데이터가 통하는 논리적 통로 각 포트는 번호로 구별되며 이 번호를 포트 번호라고 함 포트 번호는 IP 주소와 함께 쓰여 해당하는 프로토콜에 의해 사용됨 포트 번호는 크게 세 종류로 구분된다. 0번 ~ 1023번: 잘 알려진 포트 (well-known port) 1024번 ~ 49151번: 등록된 포트 (registered port) 49152번 ~ 65535번: 동적 포트 (dynamic port) 잘 알려진 포트 번호의 대표적 예는 다음과 같다. 20 : FTP(data) 21 : FTP(제어) 22 : SSH 23 : 텔넷 53 : DNS 80 : 월드 와이드 웹 HTTP 119 : NNTP 443 : TLS/SSL 방식의 HTTP References 포트 (컴퓨터 네트워킹)포트","link":"/2019/10/18/port/"},{"title":"인터렉션 테스트","text":"리스트 페이지마소니(랜덤 상자) 레이아웃Masonry 무작위(정사각형, 가로, 세로 직사각형)의 상자가 무작위로 배치 임시 구현Test 무작위 및 랜덤한 모양의 박스 배열 각 게시물 상자의 넓이는 같게 뿌려지며, 추천수가 많을수록 크기가 커지는 레이아웃 셀렉트로 원하는 게시물 및 순위 조회 가능 팝업 뷰파노라마 사진 활용Airpano 파노라마 사진을 활용하여 인테리어 게시물을 3D 형태로 출력 입체적인 컨텐츠로 사용자가 직접 둘러볼 수 있음 임시 구현Test 해당 3D 형태에 원하는 핀 및 태그를 활용하여 해당 소품들의 정보를 전달 임시 구현Test","link":"/2020/04/05/ui-interaction-test/"},{"title":"스벨트 요약","text":"REACT/VUE 에서 이젠 SVELTEW3C HTML5 Conference 2019에서 변규현 강사님의 내용을 간략하게 필기한 것 Let’s start SVELTE, goodbye React &amp; Vue 공식 문서 듀토리얼 예제 스벨트란? 코드가 간결하다. 리액트와 뷰와 스벨트를 비교했을 때 코드의 양이 차이가 많이난다. React : 442 Characters Vue : 263 Characters Svelte : 145 Charaters 가상돔을 사용하지 않는다. 반응성이다. 이는 변경된 값이 DOM에 자동으로 반영된다는 것 리액트나 뷰는 하나의 컴포넌트 및 템플릿으로 HTML을 감싸야 하지만 스벨트는 각 태그별로 사용이 가능하다. 스벨트는 에러를 빌드 타임에서 잡는다. 컴포넌트명을 예약어로도 사용 가능 컴포넌트간의 통신 가능 문법이 뷰보다 쉬움, 문법이라고 할게 없음, 상당히 쉽다. 가볍게 코드를 짤 경우 스벨트를 강력 추천 리액트의 경우 렌더링된 DOM 트리가 전의 것과 비교해서 다른 타입의 요소일때, 전 요소는 없어지고, 새로운 것을 완전히 새롭게 렌더링하는데 이를 diff 라고 한다. 리액트는 이로 인해 버벅거리는 현상이 있다. 이로 인해 스벨트와 어느 한 예제를 비교하였을때 성능차이가 거의 5배 차이가 남 References SvelteJS(스벨트) - 새로운 개념의 프론트엔드 프레임워크(updated)웹 프레임워크 Svelte를 소개합니다.","link":"/2019/10/20/svelte-seminar/"},{"title":"핀터레스트 레이아웃 구현하기","text":"핀터레스트 레이아웃 사용시 자바스크립트만으로 구현이 가능하다. Masonry 플러그인을 활용하면 좀더 다양한 인터렉션을 활용할 수 있지만 성능 및 블록 틀어짐 이슈 때문에 자바스크립트만 활용하였다. 예제 확인장점 현재 화면에 나열된 요소들의 부모를 기준으로 posirion: absolute; top: y; left: x; 속성을 활용, 각 위치에 맞게 배치하여 제이쿼리 플러그인 필요 없이 자바스크립트만으로 구현하여 가볍다. IE9까지 대응 가능 가능 하며, IE10까지만 대응한다면 top: y; left: x; 대신 transform: translate(x, y) 속성을 활용하면 성능이 좀 더 좋아진다. 단점 오직 레이아웃만 구현하여 Masonry 플러그인같은 인터렉션 효과는 없다. 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191&lt;div class=\"cntBox\"&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img01.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img02.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img03.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img04.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img03.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img04.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img01.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img02.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img01.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img02.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img03.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img04.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img03.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img04.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img01.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img02.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img01.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img02.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img03.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img04.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img03.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img04.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img01.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the of Lorem Ipsum&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"inner\"&gt; &lt;img src=\"img/img02.jpg\" /&gt; &lt;p&gt;Lorem Ipsum is simply dummy text of the printing and typesetting industry&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132* { margin: 0; padding: 0; box-sizing: border-box;}.cntBox { position: relative; margin: 0 auto; width: 100%; max-width: 1200px;}.item { display: inline-block; position: absolute; width: 20%; padding: 5px;}.item img { width: 100%;}.item .inner { border: 3px solid #ccc; border-radius: 5px;}.item .inner p { padding: 10px;} 123456789101112131415161718192021222324252627282930313233343536// 리사이즈 이벤트 한번만 실행// var timer = null;window.addEventListener('resize', function () { // 리사이즈 이벤트 한번만 실행 // clearTimeout(timer); // timer = setTimeout(boxLayout, 150); boxLayout();}, false);window.addEventListener(\"load\", function () { boxLayout();});function boxLayout() { var images = document.querySelectorAll(\".item\"); var imgStack = [0, 0, 0, 0, 0]; var boxW = document.querySelectorAll(\".cntBox\")[0].offsetWidth; var colWidth = boxW / imgStack.length; for (var i = 0; i &lt; images.length; i++) { var minIndex = imgStack.indexOf(Math.min.apply(0, imgStack)); var x = colWidth * minIndex; var y = imgStack[minIndex]; imgStack[minIndex] += (images[i].offsetHeight); // images[i].style.transform = 'translateX(' + x + 'px) translateY(' + y + 'px)'; images[i].style.left = x + 'px'; images[i].style.top = y + 'px'; if (i === images.length - 1) { document.querySelector(\".cntBox\").style.height = Math.max.apply(0, imgStack) + 'px'; } }} References 핀터레스트(Masonry) 스타일 레이아웃을 만드는 세 가지 방법","link":"/2019/12/08/ui-pinterest-layout/"},{"title":"Nginx 리눅스 명령어","text":"명령어 동작 # systemctl status nginx 상태 확인 # sudo systemctl stop nginx 웹서버 정지 # sudo systemctl start nginx 웹서버 재시작 # sudo systemctl reload nginx 설정 리로드","link":"/2020/01/04/nginx-command/"},{"title":"VIM 명령어","text":"1. vi 실행 명령어 동작 # vi file file을 연다. # vi file1 file2 file1 과 file2 를 차례로 연다. # view file file을 읽기 모드로 연다. # vi -R file file을 읽기 모드로 연다. # vi + file file을 열때 커서가 file 본문의 마지막 행에 위치한다. # vi +n file file을 열어 n행에 위치한다. # vi -r file 손상된 파일 회복 2. 입력모드 전환 명령어 동작 # i 커서 있는데서 입력모드 전환 # I 커서 왼쪽, 행의 처음에 몬자 삽입 # a 커서 있는 줄 끝에서 입력모드 전환 # A 커서 오른쪽, 행의 끝에 문자 삽입 # o 커서 있는 줄 아래에 빈 줄 삽입 # O 커서 있는 줄 위에 빈 줄을 삽입 # R 덮어쓰기 모드로 전환 3. 커서 이동 명령어 동작 # ^, 0 줄의 처음으로 이동 # $ 줄의 끝으로 이동 # H 화면 맨 위로 이동 # M 화면의 중간으로 이동 # L 화면 맨 아래로 이동 # w 다음 단어 끝으로 커서 이동 # e 다음 단어 앞으로 커서 이동 # b 이전 단어로 이동 # shift + ↑ 한 페이지 앞으로 이동 # shift + ↓ 한 페이지 뒤로 이동 # 3l, 3G 현재 커서 위치한 행에서 3번째 행으로 이동 # ctrl + i 한 화면 위로 이동 # ctrl + b 한 화면 아래로 이동 # ctrl + d 반 화면 위로 이동 # ctrl + u 반 화면 아래로 이동 # ctrl + e 한 줄씩 위로 이동 # ctrl + y 한 줄씩 아래로 이동 4. 삭제 명령어 동작 # x 한 문자 삭제 # 5x 커서가 있는 위치부터 5개의 문자를 삭제 # d + ↑ 커서있는 줄, 윗줄 2줄 삭제 # d + ↓ 커서잇는 줄, 아래줄 2줄 삭제 # dw 한 단어 삭제 # dd 한 줄 삭제 # 5dd 커서가 있는 라인부터 5개의 라인 삭제 # db 커서의 위치에서 거꾸로 한 단어 삭제 # D 한줄 내에서 커서있는 뒤 모두 삭제 # u 바로 전에 수행한 명령을 취소 # :5,10 d 5~10번째 행 삭제 5. 복사와 붙여넣기 명령어 동작 # yy 현재 줄을 버퍼로 복사 # p 버퍼에 있는 내용을 커서 뒤에 삽입 # P 버퍼에 있는 내용을 커서 앞에 삽입 # 3y 현재 줄에서부터 아래로 3줄 복사 # :5, 10y 5~10줄을 버퍼로 복사 # :30pu 30행에 버퍼 내용을 삽입 # d 현재 커서가 위치해 있는 단어 복사 # 3yy 현재 행을 기준으로 3번째 행까지 n행 복사 6. 문자열 찾기 명령어 동작 # /name name 문자열 찾기 # n 다음 name으로 이동 # N n과 같으며 역방향으로 이동 7. 문자열 대체 명령어 동작 # :s/str/rep 현재 행의 str을 rep로 대체 # :l,.s/str/rep/ 1부터 현재 행의 str을 rep로 대체 # :%s/str/rep/g 파일 전체 str을 rep로 전부 대체 # :.$/aaa/bbb 커서의 위치로부터 파일의 끝까지 있는 모든 aaa를 bbb로 대체 8. 파일 저장 및 불러오기 명령어 동작 # :w 지정된 파일에 저장 # :wq, :x, ZZ 지정된 파일에 저장하고 vi를 종료 # :w php.ini php.ini 파일에 저장 # :q 저장하지 않고 종료 # :q! 저장하지 않고 강제 종료 # :wq php.ini php.ini에 저장하고 vi를 종료 # :r php.ini php.ini의 내용을 현재 커서가 있는데로 불러온다. # :e php.ini 현재의 화면을 지우고 새로운 파일 php.ini를 불러온다. # :5,10 w php.ini 5~10 줄까지의 내용을 php.ini에 저장 9. 기타 명령어 동작 # :set nu 행 번호 보여주기 # :set nonu 행 번호 보여주기 취소 # . 바로 전에 실행한 명령어 재 실행 # ctrl + l 불필요한 화면 정리후 다시 표시 References Linux 문서편집기 vi, vim 명령어 정리","link":"/2019/12/06/vim-command/"},{"title":"Vue Cli 초기 세팅","text":"Vue CLICLI는 Command Line Interface의 약자로 윈도우에서는 Command 창, 맥에서는 터미널 창에서 타이핑으로 명령어를 입력하여 원하는 바를 실행 시키는 도구를 말한다. 쉽게 Vue 프로젝트를 개발할 수 있게 해주는 아주 유용한 도구이다. Vue CLI은 내부적으로 Webpack을 활용한다. Vue CLI로 명령을 실행 시키면 CLI가 자동으로 최적화된 Webpack 형태의 결과물을 생성 시켜 준다. Vue CLI 2.x 와 Vue CLI 3.x 버전 비교프로젝트를 생성 CLI2 : eslint, unit test, night watch 등 낯선것들 선택 필요 CLI3 : default (babel, eslint) 를 선택하면 가장 기본적인 설정으로 프로젝트가 생성, 나중에 옵션을 추가 가능작성 필요 프로젝트 구성 CLI2 : simple, webpack, webpack-simple, pwa 등 템플릿 리스트 중 하나를 선택해서 프로젝트 구성 CLI3 : 프로젝트에 플러그인 기반으로 원하는 설정 추가 웹팩 설정 파일 CLI2 : webpack.config.js 파일이 최상단 디렉터리에 있다. CLI3 : 없음, root 디렉터리에 vue.config.js 파일을 설정하고 내용 추가 ES6 이해도 CLI2 : 필요 X CLI3 : 필요 O node modules CLI2 : 자동설치 안됨. $ npm install 필요 CLI3 : 자동설치 설치 환경 node.js npm CLI 설치12$ npm i -g @vue/cli // vue-cli 3.x$ npm i -g vue-cli // vue-cli 2.x 버전 확인12$ vue --version@vue/cli 4.0.5 프로젝트 생성babel과 eslint 기반인 default 옵션을 선택한다. 12$ vue create 'ProjectName' // vue-cli 3.X$ vue init webpack 'ProjectName' // vue-cli 2.X 로컬 서버 실행12$ npm run serve // vue-cli 3.x$ npm run dev // vue-cli 2.x http://localhost:8080/ 로 들어가면 뷰 로고가 있는 로컬 페이지를 볼 수 있다.$ npm install 명령어를 통해 NPM패키지를 설치하지 않아도 서버가 작동되는 것을 확인할 수 있는데 vue cli가 이미 node_modules디렉터리 안에 라이브러리들을 다운받았기 때문이다. vue cli의 기본 템플릿은 babel, eslint, unit-mocha 를 포함한다. Babel: 자바스크립트 컴파일러다. 최신버전의 자바스크립트 문법은 브라우저가 이해하지 못하기 때문에 Babel은이 브라우저가 이해할 수 있는 문법으로 변환시켜준다. ES6, ES7 등의 최신 문법을 사용해서 코딩을 할 수 있기 때문에 생산성이 향상된다. ESLint: 코딩 스타일 가이드를 따르지 않거나 문제가 있는 코드나 안티 패턴을 찾아 표시를 달아 놓는 도구이다. unit-mocha: javascript 진영에서 테스트 러너를 지원하는 테스트 프레임워크이다. References Vue CLI 3.0 사용하기Vue CLI 3.X 사용하기Vue CLI 3 사용법[Vue.js] Vue Version 비교 (cli2 vs cli3)Vue-CLI 도구 활용방법","link":"/2019/11/01/vue-cli-init/"},{"title":"Vue Cli 2.x를 이용한 Github페이지 만들기","text":"Vue Cli 2.x 버전을 이용하여 프로젝트를 생성하고 깃허브 페이지에 적용하는 방법을 알아보도록 한다. 설치 시작프로젝트 설치할 디렉토리로 가서 웹팩 설치뒤에 해당 디렉토리로 이동, npm까지 설치해준다. 123$ vue webpack init 'projact name'$ cd 'projact name'$ npm install 설치가 완료되면 config 디렉토리의 index.js파일을 열어준 뒤 build 값을 아래처럼 수정해준다. 1234567891011build: { index: path.resolve(__dirname, '../docs/index.html'), assetsRoot: path.resolve(__dirname, '../docs'), assetsSubDirectory: 'static', assetsPublicPath: '', productionSourceMap: true, devtool: '#source-map', productionGzip: false, productionGzipExtensions: ['js', 'css'], bundleAnalyzerReport: process.env.npm_config_report} 수정되는 항목 index 에서 dist &gt; docs assetsRoot 에서 dist &gt; docs assetsPublicPath 에서 '/' &gt; '' 수정이 완료되면 빌드해준다. 1$ npm run build 빌드후에 깃허브 원격저장소에 push를 해준뒤 원격저장소 세팅페이지로 들어간다.GitHub Pages 항목에서 Source 옵션을 master branch /docs folder로 선택해주면 끝이다.페이지 url은 https://[유저이름].github.io/[저장소이름]/ 로 들어가면 된다. 위에까지의 과정은 이곳에 쉽게 잘 정리되어 있다. References vue github page 만들기Problems deploying to github pages with vue project","link":"/2019/11/02/vue-cli2-github-page/"},{"title":"Vue Cli 3.x를 이용한 Github페이지 만들기","text":"Vue Cli 2.x 버전을 이용하여 프로젝트를 생성하면 웹펙 설정파일이 자동으로 생성되지만 3.x 버전부터는 직접 만들어줘야 한다. 때문에 2.x 버전하고 방법이 약간 다르다. 설치 시작설치할 디렉터리로 가서 프로젝트를 생성해 준다. 1$ vue create 'ProjectName' 프로젝트 폴더로 이동하여 원격 저장소에 연결시켜 준 뒤 푸쉬해준다. 123cd 'ProjectName'git remote add origin 'url'git push origin master 코드를 빌드하면 dist 디렉토리에 출력되어도록 되어있기 때문에 vue.config.js 파일을 만들어서 설정을 변경해둔다. 우선 최상단 디렉터리에 vue.config.js파일을 생성해 준 뒤 아래 코드를 입력해준다. 원격 저장소의 프로젝트명과 동일하게 publicPath를 수정해준다. 12345// vue.config.js module.exports = { publicPath: '/ProjectName/', outputDir: 'docs'} 빌드를 하면 /docs 디렉토리가 생성된다. 후에 최상단 디렉터리의 .gitignore 파일에 /dist 를 주석처리 해준다. 이제 깃에 푸쉬해준다. 123git add ./git commit -m &quot;commit message&quot;git push origin 이제 깃허브로 들어가서 저장소 설정으로 간 뒤 GitHub Pages 항목에서 master branch /docs folder 를 셀렉해준다. 이제 https://[유저이름].github.io/[저장소이름] 으로 들어가면 뷰 페이지를 확인할 수 있다. (반영에 시간이 조금 걸린다. 당분간은 404가 표시되어있다.) References vue-cli で作ったサイトを GitHub Pages にデプロイするDeploy vue-cli 3 project to github pages","link":"/2019/11/05/vue-cli3-github-page/"},{"title":"CentOS7 깃 설치 및 로컬 세팅","text":"초기 설치 환경서버 Centos7 Nginx MySQL5.7 PHP7.1 로컬 Homestead Git 설치원격 저장소 만들고 ssh 접속하여 root권한으로 변경 1# su root yum을 이용해서 git 설치 1# yum install git-core yum을 이용해서 git 설치 1# yum install git-core 설치된 영카트 디렉토리로 이동 1# cd /data/web_htdocs/ 깃 초기화 1# git init 파일 상태를 확인해 깃이 잘 설치되어 있는지 확인 1# git status 전역 사용자 등록(원격 저장소에 있는 아이디와 메일이 일치하도록 설정) 12# git config --global user.name &quot;사용자 이름&quot;# git config --global user.email &quot;사용자 메일&quot; 원격 저장소 url을 복사하여 git에 연동 1# git remote add origin `원격 저장소 url` 로컬 소스트리 클론원격 저장소 url 복사 1# git remote add origin `원격 저장소 url` 설치할 디렉토리 경로 맞춘 뒤 클론 1# git remote add origin `원격 저장소 url` 로컬 세팅Homestead.ymal 파일 열고 site 부분에 12map: 로컬 도메인 주소to: vagrant 경로 추가 123$ vagrant reload --provision$ sudo service nginx restart// (nginx 백업 필수 설정 다시 해줄것!) host 파일에 로컬주소 추가(관리자권한으로 실행)C:\\windows\\system32\\drivers\\etc 실서버 디비 백업1$ mysqldump -p db명 &gt; 저장할 파일이름.sql 해당 파일 찾아서 local DB 인 Homestead에 넣어주기symlink(): Protocol error 에러 뜰경우 Git Bash 를 관리자 권한으로 실행 후 1$ php artisan storage:link 또는 관리자 권한으로 실행 후 1$ vagrant up 한 다음 새로고침 해볼것 배포 해보기로컬에서 소스 수정 후 commit, push 하고 쉘 접속하여 수정 부분 받기 12$ cd /data/web_htdocs/$ git pull error cannot open .git/fetch_head permission denied 에러 날경우.git 파일의 권한이 root 여서 오류남, 일반 계정으로 변경 해야함, 루트 계정으로 접속 12345$ su rootPassword: 패스워드 입력chown -R webapp:webapp /data/web_htdocs/.gitls -al 해당 파일 변경해준 권한인지 확인exit 다시 git pull, 그래도 안된다면 1$ git pull origin master 또는 12$ git branch --set-upstream-to=origin/master master$ git pull","link":"/2019/12/11/centos-youngcart-git/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"ui","slug":"ui","link":"/tags/ui/"},{"name":"vanillaJs","slug":"vanillaJs","link":"/tags/vanillaJs/"},{"name":"vue.js","slug":"vue-js","link":"/tags/vue-js/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"web crawling","slug":"web-crawling","link":"/tags/web-crawling/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"centos","slug":"centos","link":"/tags/centos/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"seo","slug":"seo","link":"/tags/seo/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"youngcart5","slug":"youngcart5","link":"/tags/youngcart5/"},{"name":"apache","slug":"apache","link":"/tags/apache/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"svelte.js","slug":"svelte-js","link":"/tags/svelte-js/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"ui","slug":"ui","link":"/categories/ui/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"vue.js","slug":"vue-js","link":"/categories/vue-js/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"centos","slug":"centos","link":"/categories/centos/"},{"name":"github","slug":"github","link":"/categories/github/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"svelte.js","slug":"svelte-js","link":"/categories/svelte-js/"},{"name":"jquery","slug":"jquery","link":"/categories/jquery/"}]}