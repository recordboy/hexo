{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"자바스크립트 소개","text":"자바스크립트는 프로토타입 기반의 스크립트 언어이다. 주로 웹 브라우저 내에서 주로 사용되며 Node.js 와 같은 런타입 환경과 같이 서버 사이드 프로그래밍에도 사용되고 있다. 창시자는 넷스케이프사의 브렌던 아이크이다. 자바스크립트의 역사초창기 자바스크립트는 웹 페이지 제작에 있어서 보조적인 기능을 수행하기 위한 용도로써 사용되었다. 클라이언트인 웹 브라우저에서 서버로부터 받은 HTML과 CSS, 데이터로 렌더링을 해주는 수준이였다. 이 시절에 자바스크립트는 그다지 중요한 역할을 담당하지 못했다. 하지만 소수의 프로그래머들에 의해 여러 가지 연구가 이루어졌고, 웹 아키텍쳐에도 크고 작은 변화가 일어났다. 특히 과거에 서버에서 담당했던 역할들이 상당 부분 웹 브라우저로 이동하였고, 자바스크립트는 이 변화의 중점에 서게 된다. 게다가 jQuery 의 등장으로 보다 쉽게 DOM을 핸들링하게 되면서 많은 발전을 이루었다.현재는 브라우저 기반의 자바스크립트 라이브러리 뿐만 아니라 Node.js와 같은 서버 기반의 자바스크립트 환경에서 동작할 수 있는 각종 라이브러리까지 쏟아져 나오고 있다.이제는 자바스크립트만으로 웹 서버와 클라이언트인 웹 페이지 개발을 동시에 할 수 있는 수준까지 왔다고 볼 수 있다. 자바스크립트 언어의 특징자바스크립트는 클래스를 지원하지 않지만 객체지향 프로그래밍이 가능하다.여기서 객체 지향 프로그래밍(OOP)에 대해 잠깐 짚어본다. 객체 지향 프로그래밍(OOP)줄여서 OOP 라고 부르겠다. OOP는 컴퓨터 프로그래밍 패러다임중 하나이며, 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 “객체” 들의 모임으로 파악하고자 하는 것이다. 각각의 객체들은 메시지를 주고받고, 데이터를 처리할 수 있다. 객체지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용되고, 보수를 간편하게 하며 보다 직관적인 코드 분석을 가능하게 하는 장점을 가지고 있다. 객체지향의 반대로는 절차지향 프로그래밍(procedural Programming)이라는 패러다임이 있다. 절차지향 프로그래밍이란 순차적인 처리가 중요시되며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 대표적인 절차지향 언어에는 C언어가 있다. OOP의 특성으로는 추상화(Abstraction), 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism)이 있으며 이 개념은 추후에 알아보도록 하겠다.","link":"/2017/02/01/javascript-introduce/"},{"title":"자바스크립트 변수","text":"프로그래밍에서 기본이 되는 데이터를 담는 공간이다. 어떠한 값을 저장하기 위한 공간이면서 변할수 있다는 뜻을 가지고 있다. 변수의 반대말로는 변하지 않는 상수가 있다. 선언 방법은 var 라는 키워드를 사용한다. 1var 변수이름 = 저장데이터; = 는 대입 연산자로서 우측에 있는 값을 왼쪽에 있는 변수에 담는 연산자다. 세미콜론(;)은 문장의 끝을 알린다. 오류를 방지하기 위해 문장이 끝나면 꼭 선언해 주도록 하자 참고로 함수 선언식에서는 마지막에 세미콜론을 붙이지 않는데 이건 하나의 관습이고, 코드 작성시 권장되는 방식이다. 그리고 자바스크립트에서는 세미콜론 사용을 강제하지는 않는다. 그 이유는 자바스크립트 인터프리터가 자동으로 세미콜론을 삽입시켜 주기 때문이다. 하지만 세미콜론을 꼭 선언해 주는 습관을 가지도록 해야한다. 신경을 안쓴다면 코드를 압축하거나 디버깅 할시에 심각한 오류를 가지게 될수 있기 때문이다. 변수는 크게 네가지로 나뉠수 있으며 종류는 전역변수(Global Variable) : 전역에서 사용되는 변수로서 어디서든 접근이 가능하다. 지역변수(Local Variable) : 특정 지역에서 사용되는 변수로서 보통 함수 내부에 만들어 지는 변수 매개변수(Parameter) : 함수 외부에서 데이터를 받아 올때 사용되는 변수 속성(Property) : 객체의 속성값으로 쓰이는 변수이다. 참고로 전역 객체는 window 객체이다. 전역변수를 선언한다면 자동으로 window 객체의 프로퍼티가 된다고 생각하면 된다. 아래 코드를 참고 123var obj = { name: \"foo\" // name = 속성(프로퍼티, 아니면 키), foo = 속성의 값(프로퍼티 값 아니면 키값)}; 인자(Arguments)와 매개변수(Parameter)에 대해 많이 헷갈려 했었는데, 인자는 함수를 호출할때 대입하는 값을 의미하고 매개변수는 함수 내에 있는 값을 의미한다고 볼 수 있다. 1234function func(foo){ return foo; // foo = 매개변수}func(\"value\"); // \"value\" = 인자 변수를 만들때는 주의사항이 네가지 있다. 변수명은 대소문자를 구분해야 한다. 변수명은 소문자로 시작하고, 관례상 카멜기법을 사용한다. 여기서 카멜기법이란 문자모양이 낙타와 비슷하다고 해서 지어졌다. 네이밍 기법은 3가지로 분류할수 있다. 카멜기법(myName) 스네이크 기법(my_name) 파스칼 기법(my-name) 한번 저장하고 변하지 않는 상수값은 모두 대문자로 작성한다. 자바 언어 같은 경우 상수 값을 만드는 방법이 지원되지만 자바스크립트는 없다. 그래서 관례상 대문자로 작성하는 것이다. 예가 몇가지 있는데 슬라이드 플러그인에서 사용자가 정의하는 변수나 그누보드의 config.php 에 나와있는 상수 선언 등이 있다. 키워드(예약어)를 사용하면 안된다.(예: var, function, break 등등 아주 많음) 예약어로 변수를 선언하면 브라우저에서 오류 메세지가 출력되므로 많은 예약어를 따로 외울 필요는 없다.","link":"/2017/05/02/javascript-variable/"},{"title":"자료형(원시 타입)","text":"자료형은 데이터 값의 유형이다.원시타입과 객체(참조)타입으로 나눌 수 있는데 원시타입으로는 문자열(String), 숫자(Number), 논리형(Boolean), 언디파인드(Undefined), 널(Null) 값이 있다. 객체(참조)타입으로는 객체(Object), 배열(Array), 함수(Function)가 있다. 여기서 객체(참조)타입과 객체(Object)의 차이에 대해 혼동하기 쉽다. 객체(참조)타입은 기본타입을 제외한 모든 자바스크립트의 객체를 가르키며, 객체(Object), 배열(Array), 함수(Function)도 객체(참조)타입 에 포함된다. 객체(Object)는 자바스크립트에서 표현되는 자료형의 값이며 객체(참조)타입중에 하나인 객체(Object)이다. 기본타입문자(String)우리가 실생활에서 쓰고 있는 글자를 문자열이라고 생각하면 된다. 변수에 담는 방식은 큰따옴표나 작은 따옴표로 감싸서 저장하시면 된다. 문자열에 따옴표를 포함하고 싶으면 다른 따옴표로 감싸주면 된다. 12var str = 'data'; // 문자열을 담을 때var str = \"'data'\"; // 작은 따옴표를 문자열에 추가하고 싶을때 참고로 따옴표를 문자열로 인식하고 싶을때는 역슬래쉬를 따옴표 앞에 붙여 사용하면 된다. 이 작업을 이스케이핑이라고 부른다. 1var str = \"'data'\"; // 작은 따옴표를 문자열로 인식하고 싶을때 숫자(Number)우리가 알고있는 숫자라고 생각하면 된다. 자바스크립트는 모든 숫자를 64비트 부동소숫점 형태로 저장하기 때문에 하나의 타입만 존재하며 형태는 크게 정수형(10진수, 16진수), 실수형으로 나뉜다. 정수형(10진수) : 평상시에 사용하는 10진수이며, 소숫점이 없다. 정수형(16진수) : Ox로 시작하며 숫자 09와 문자 AF를 사용해서 숫자를 표현한다. 보통 색상을 나타낼때 사용한다.(예 : 0xF00) 실수형 : 소숫점을 갖는 숫자 자바스크립트는 소숫점을 계산할때 한가지 오류가 있는데 확인하고 넘어가자하단의 코드를 보면 1console.log(0.1 + 0.2); 결과는 0.3 이 나올겉 같지만 0.30000000000000004 가 출력이 된다. 이것이 부동소수점 오류며 아래와 같은 방법으로 해결을 할 수 있다. 주의하도록 하자. 1console.log(((0.1*10)+(0.2*10))/10); 논리형(Boolean)쉽게 설명해서 참, 거짓이라고 생각하면 된다. 참 : true 거짓 : false 데이터 타입마다 true, false로 변환되는 값이 다르다. 데이터 타입 true로 변환되는 값 false로 변환되는 값 불리언 true flase 문자열 비어 있지 않은 모든 문자열 “”(빈 문자열) 숫자 0이 아닌 모든 숫자(무한대 포함) 0, NaN 객체 모든 객체 null Undefined 해당 없음 undefined 널(Null)널은 아무것도 참조하고 있지 않다라는 의미이다. 여기서 언디파인드와 널이 많이 헷갈릴 수가 있다. 언디파인드는 값 자체가 선언이 되지 않은거고 널은 임의로 빈 값으로 선언한 상태라고 보면 된다. 널은 객체를 담을 변수를 초기화할때 많이 사용한다. 1234var num = 0; // 숫자 초기화var str = ''; // 문자 초기화var boolean = false; // 논리형 초기화var obj = null; // 객체 초기화","link":"/2017/05/03/javascript-primitive-data-type/"},{"title":"자료형(참조 타입)","text":"이전 포스팅에서도 언급했지만 참조타입으로는 객체(Object), 배열(Array), 함수(Function)가 있다. 원시타입과 참조타입을 비교하는것에 초점을 두어 간단히 알아본다. 객체(Object)자바스크립트에서 객체는 단순하게 표현하면 속성명(Key), 값(value) 형태의 속성(property)을 저장하는 그릇이라고 생각하면 된다. 즉 여러 값을 표현하는 묶음을 만들때 사용된다. 간단한 객체를 만들어 보겠다. 1234var person = { name: '철수', age: '20'}; 속성명은 name, age 값은 ‘철수’, ‘20’인 객체를 선언했다. 객체 선언 방식은 {}(중괄호)로 한다. 이 선언 방식은 객체 리터널 방식이라고 하며, 리터널이란 용어의 의미는 표기법이라고 생각하면 된다. 리터널 방식은 간단한 표기법만으로도 객체룰 생성할 수 있는 자바스크립트의 강력한 문법이다. 객체의 프로퍼티에 접근하려면 마침표 표기법과 대괄호 표기법이 있다. 1console.log(person.name); // 철수 배열(Array)배열은 변수에 여러가지의 값을 한번에 담을 수 있는 그릇이라고 볼 수 있다. 위에 언급한 객체와 비슷해 보일 수 있지만 배열의 속성명은 각 프로퍼티의 인덱스 값이다. 선언방식은 [](대괄호)로 하고 객체와 마찬가지로 이는 배열 리터널이다. 1var person = ['철수', '20']; 객체와는 다르게 배열의 속성명은 인덱스 값이라고 했다. 그러므로 person의 첫번째 값인 ‘철수’의 속성명(Key)은 배열의 첫번째 인덱스인 0이고, 두번째 값(value)인 ‘20’의 속성명은 1이 되는 것이다. 배열의 프로퍼티에 접근하려면 대괄포 표기법을 이용하면 된다. 12console.log(person[0]); // 철수 console.log(person[1]); // 20 함수(Function)함수는 특정 기능을 하는 구문(알고리즘, 로직)을 독립된 부품으로 만들어 재사용하고자 할때 사용하는 문법이다. 함수를 선언할때는 function키워드를 사용하며 구조는 아래에서 확인할 수 있다. 1234function 함수이름(파라미터){ // 알고리즘 return 값 // 리턴 값} 객체(참조)타입이 무엇이 있나 간단히 봤다. 원시타입과 객체(참조)타입의 차이점을 알아보도록 하자 원시 타입과 참조 타입의 차이자바스크립트에서는 원시타입인 숫자, 문자열, 논리형, 널, 언디파인드 다섯가지를 제외한 모든 값은 객체(참조)타입 이다. 참조 타입이라고 불리는 이유는 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문이다. 아래 예제를 살펴 보자 12345var num1 = 10, num2 = num1;console.log(num2); // 10 num1 = 20;console.log(num2); // 10 원시타입은 값 자체를 비교한다.변수 num1에다가 10을 대입하고 num1를 num2에 대입했다. 변수에 할당된 값 자체를 복사하였기 때문에 num2의 값은 10이다. num2에 20을 대입해도 num2의 값은 변하지 않는다. num2에 직접적으로 값을 대입하지 않았기 때문이다.아래 참조타입을 보자 1234567var obj1 = { val: 10};var obj2 = obj1;console.log(obj2.val); // 10obj1.val = 20;console.log(obj2.val); // 20 우선 obj1에 객체 리터널을 선언하고, val 프로퍼티에 10을 담았다. 그리고 obj2에 obj1을 할당했다. obj2의 val프로퍼티의 값은 10이 출력된다. 여기서 obj1의 val에 20을 담았다. obj2의 val값을 건들지도 않았는데 obj1 처럼 val값이 20으로 봐뀌어있다. 어떻게 된 것일까? 값 자체가 복사되는 원시값과는 달리 참조타입은 참조(객체를 가르키는 참조값 혹은 메모리 주소)만 복사되고 실제 값은 복사되지 않는다. 즉 obj1과 obj2는 실제 데이터를 가지고 있는 객체의 주소값만 가지고 있는 것이다.","link":"/2017/05/05/javascript-reference-data-type/"},{"title":"GET과 POST 차이","text":"HTTP 웹상에서 클라이언트와 서버 간에 데이터를 주고 받을 수 있는 프로토콜 HTTP 메소드에는 2가지 방식이 있는데, 그것이 GET 방식과 POST 방식 GETURL에 파라미터를 포함시켜 요청하는 방식이다. 예를들어 https://recordboy.github.io/login?id=user&amp;pw=1234 라는 페이지가 있다고 치자, ? 마크를 통해 URL의 끝을 알리고, id라는 키(key)에 대해선 user라는 값(value)를, pw라는 키(key)에 대해서는 1234라는 값(value)을 전송한 것을 볼 수 있다. 여러개의 키와 값을 보낼 때는 &amp;를 사용하여 이어준다. 이처럼 데이터가 노출되기 때문에 보안에 취약하며, 개인정보가 포함되지 않는 상황에서 캐싱을 하여 페이지 로딩 속도를 높일 때 사용된다. 특징 URL에 파라미터를 포함시켜 요청한다. 데이터를 Header(헤더)에 포함하여 전송한다. URL에 파라미터가 노출되어 보안에 취약하다. 캐싱할 수 있다. GET 방식은 글자수 제한이 있지만, 256자 라는 말은 사실이 아니다. 익스 9의 경우 2083자/최대 5120자를 지원사파리는 40만자를 넘기면 브라우저가 크러쉬파이어폭스/오페라는 길이 제한이 없고 50만자를 넘겨도 별다른 이상 없음크롬의 경우 4만자를 기준 POSTPOST는 제출하다라는 뜻으로 BODY에 데이터를 넣어 전송하며 길이의 제한이 없다. 따라서 GET과 다르게 대용량 데이터를 전송할 수 있으며, BODY에 전송되어 내용이 눈에 보이지 않아 보안적으로 안전하다고 할 수 있다. 하지만 POST요청도 크롬 개발자 도구같은 툴로 요청내용을 확인할 수 있기 때문에 민감한 데이터는 반드시 암호화 하여 전달해야 한다.그리고 POST로 요청을 보낼 때는 요청 헤더의 Content-Type에 요청 데이터의 타입을 명시해야 한다. 종류는 여러가지가 있지만 몇가지 나열해보면 application/x-www-form-urlencoded GET방식과 마찬가지로 BODY에 key와 value쌍으로 데이터를 넣는다. 똑같이 구분자 &amp;를 쓴다. text/plain BODY에 단순 텍스트를 넣는다. multipart/form-data 파일전송을 할때 많이 쓰는데 BODY의 데이터를 바이너리 데이터로 넣는다는걸 알려준다. 특징 BODY에 데이터를 넣어 전송하며 길이의 제한이 없어 대용량 데이터를 전송할 수 있다. BODY에 데이터가 들어가기 때문에 GET보다는 보안상 유리하지만 민감한 데이터는 꼭 암호화를 해줘야 한다. 요청 헤더의 Content-Type에 요청 데이터의 타입을 명시해야 한다. References GET과 POST의 차이[Web] GET과 POST의 비교 및 차이get 방식의 글자 256자 제한은 잘못된 상식GET방식 과 POST방식","link":"/2017/12/04/get-post/"},{"title":"자바스크립트 반올림, 올림, 내림","text":"반올림Math.round(); 12var num = 3.5;console.log(Math.round(num)); // 4 올림Math.ceil(); 12var num = 3.5;console.log(Math.ceil(num)); // 4 내림Math.floor(); 12var num = 3.5;console.log(Math.floor(num)); // 3","link":"/2017/11/01/javascript-math-round/"},{"title":"자바스크립트 eval() 함수","text":"eval() eval()은 전역 객체(window)의 함수 속성이다. eval()의 인자는 문자열이며 문자열 형태를 연산할 수 있다. 12345console.log('2 + 2');// 2 + 2console.log(eval('2 + 2'));// 4 eval() 문제점 굳이 eval() 함수를 쓰지 않아도 충분히 동일한 동작을 구현할 수 있는 경우가 많다. 보안상 위험한 javascript 코드를 실행할 수 있다는 위험때문에 eval() 함수는 권장되지 않는다. References eval()eval() 사용과 문제점 : #eval() is evilJavaScript eval 함수","link":"/2017/12/01/javascript-mehod-eval/"},{"title":"자바스크립트 스코프(Scope)","text":"자바스크립트에서의 스코프란 코드가 실행되는 컨텍스트(유효범위)이며 전역 스코프, 지역 스코프, eval 스코프로 나눌 수 있다. 전역 스코프 함수나 객체의 밖에서 선언되었다면 전역 스코프로 정의된다. 모든 곳에서 전역 스코프에 있는 변수를 사용할 수 있다. 12345678// 전역 스코프var foo = 1;console.log(foo); // 1function func() { // foo가 전역에서 선언되었기 때문에 함수 내부에서도 foo값을 사용할 수 있다. console.log(foo); // 1} 지역 스코프 함수나 객체의 안에서 선언되었다면 지역 스코프로 정의된다. 해당 함수나 객체에서만 지역 스코프를 사용할 수 있다. 함수 지역 스코프123456789function func() { // 지역 스코프 var foo = 1; console.log(foo); // 1}// foo가 func 함수 내부에서 선언되었기 때문에 함수 외부에서 사용을 할 수 없다.console.log(foo); // Uncaught ReferenceError: foo is not defined 객체 지역 스코프12345var obj = { foo: 1};console.log(obj.boo); // 1console.log(boo); // Uncaught ReferenceError: foo is not defined eval 스코프 eval의 경우 eval()을 사용해 매개변수를 사용하면 이를 사용했을 경우에만 해당 스코프에 담긴 값을 불러온다. 각각 선언할때 고유한 스코프를 가지는 것이 특징이다.","link":"/2017/12/02/javascript-scope/"},{"title":"자바스크립트 노드 생성 및 추가","text":"노드 생성 1var input = document.createElement('input'); 생성된 노드 속성 추가 1input.setAttribute('type', 'text'); 텍스트 노드 추가 1var txt = document.createTextNode('hello'); 부모 노드에 생성된 노드 추가 1부모노드.appendChild(input); 테이블 생성 예제위 노드 추가 방법으로 테이블 추가 예제를 만들어 보자, 버튼을 계속 클릭하면 테이블이 추가된다. 1234&lt;div class=\"wrap\"&gt; &lt;button id=\"btn\"&gt;click&lt;/button&gt; &lt;table id=\"tbl\"&gt;&lt;/table&gt;&lt;/div&gt; 1234567891011121314151617181920212223.wrap { position: relative; padding-top: 40px;}.wrap * { margin: 0; padding: 0}#tbl td { border: 1px solid #ccc; padding: 3px 10px; text-align: center;}#btn { position: absolute; top: 0; left: 0; width: 50px; height: 30px;} 1234567891011121314151617181920212223242526272829303132333435window.onload = function () { // 노드 선언 var btn = document.getElementById('btn'), tbl = document.getElementById('tbl'), tblTr = tbl.getElementsByTagName('tr'); // 버튼 이벤트 btn.addEventListener('click', function () { tblAdd(); }); // 테이블 추가 function tblAdd() { var tr = document.createElement('tr'); for (var i = 0; i &lt; 5; i++) { var td = document.createElement('td'); tr.appendChild(td) }; tbl.appendChild(tr); numAdd(); } // 테이블 번호 추가 function numAdd() { var num = 0; for (var i = 0; i &lt; tblTr.length; i++) { for (var j = 0; j &lt; tblTr[i].getElementsByTagName('td').length; j++) { num++; tblTr[i].getElementsByTagName('td')[j % 5].innerHTML = num; }; }; }} 구현 .wrap { position: relative; padding-top: 40px; } .wrap * { margin: 0; padding: 0 } #tbl td { border: 1px solid #ccc; padding: 3px 10px; text-align: center; } #btn { position: absolute; top: 0; left: 0; width: 50px; height: 30px; } window.onload = function () { // 노드 선언 var btn = document.getElementById('btn'), tbl = document.getElementById('tbl'), tblTr = tbl.getElementsByTagName('tr'); // 버튼 이벤트 btn.addEventListener('click', function () { tblAdd(); }); // 테이블 추가 function tblAdd() { var tr = document.createElement('tr'); for (var i = 0; i < 5; i++) { var td = document.createElement('td'); tr.appendChild(td) }; tbl.appendChild(tr); numAdd(); } // 테이블 번호 추가 function numAdd() { var num = 0; for (var i = 0; i < tblTr.length; i++) { for (var j = 0; j < tblTr[i].getElementsByTagName('td').length; j++) { num++; tblTr[i].getElementsByTagName('td')[j % 5].innerHTML = num; }; }; } } click References HTML DOM appendChild() Method","link":"/2017/12/12/javascript-append-child/"},{"title":"날짜 구하기(Data 함수)","text":"DataData 객체는 날짜와 시간을 제공하는 생성자 함수이다.인자 없이 객체를 선언하면 현재 날짜와 시간을 반환한다. 123var value = new Date();console.log(value);// Thu Jan 09 2020 14:44:13 GMT+0900 (한국 표준시) 특정 값을 구하는 메서드 메서드 값 getFullYear() 년 getMonth() 월 getDate() 날짜 getDay() 요일 응용2015년 12월 25일의 요일을 구하는 법 1234function func(a, b) { return ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'][new Date(2015, a - 1, b).getDay()];}console.log(func(12, 25)); // FRI References 프로그래머스 문제 풀이 Level 1","link":"/2017/12/13/javascript-date/"},{"title":"문자열 자르기","text":"split()특정 문자열을 기준으로 잘라 배열로 반환한다. 123var str = '가, 나, 다, 라, 마'console.log(str.split(','));// (5) [\"가\", \" 나\", \" 다\", \" 라\", \" 마\"] substring(시작인덱스, 종료인덱스)시작인덱스를 기준으로 종료인덱스 까지 자른다. 123var str = '가나다라마'console.log(str.substring(1, 4));// 나다라 substring(시작인덱스, 길이)시작인덱스를 기준으로 문자열 길이로 자른다. 123var str = '가나다라마'console.log(str.substr(2, 2));// 다라","link":"/2017/12/04/javascript-truncate-string/"},{"title":"배수 구하기","text":"0부터 100까지 특정 배수를 구하는법이다.반복문과 조건문, 나머지 연산자가 사용된다. 123for(var i = 0;i &lt;= 100;i++){ console.log(i);}; i가 증감되면서 콘솔창에 1부터 100까지 차례로 출력될 것이다. 그렇다면 아래의 코드는 어떻게 출력될까? 123for(var i = 0;i &lt;= 100;i++){ console.log(i % 3);}; 12345670 1 2 0 1 2 . . . 0부터 2는 3으로 나눠지지 않기때문에 첫번째 피연산자가 출력되고 3은 나눠지기 때문에 0이 출력된다. 그 이후로는 3으로 나눈 뒤 나머지가 출력되기 때문에 위처럼 0, 1, 2, 0, 1, 2 .. 로 출력된다. i값이 3으로 나머지 없이 나눠지면 0이 출력되는걸 확인할 수 있다. 이걸 통해 조건문으로 3의 배수를 구할 수 있는 것이다. 12345for(var i = 0;i &lt;= 100;i++){ if(i % 3 === 0){ console.log(i); };}; 나머지 없이 3으로 나눠 질때만 i값이 출력된다. 하지만 i값이 0일 때도 같이 출력된다. 다중 조건문을 추가해 주자 12345for(var i = 0;i &lt;= 100;i++){ if(i % 3 == 0 &amp;&amp; i !== 0){ console.log(i); };}; 3의 배수가 원활하게 출력되는걸 확인할 수 있다.","link":"/2017/12/14/algorithm-multiple/"},{"title":"증가 감소","text":"슬라이드 배너 코드를 작성할 때 이전 슬라이드, 다음 슬라이드 인덱스 값이 필요할 경우 쓰이는 방법이다. 슬라이드 갯수와 다음, 이전 인덱스 값을 초기 설정해준다. 123var slideLength = 4, next = 0, prev = 0; 알고리즘이 들어갈 함수와 이벤트를 실행시킬 이벤트 리스너가 필요할 것이다.slide 함수를 선언하고 setInterval 함수에다가 이벤트 리스너를 등록하자 1234function slide(){ console.log(0);}setInterval(slide, 1000); 1초마다 콘솔창에 0이 출력된다. 이제 1초마다 다음 인덱스에 1을 더하며 그 값을 이전 인덱스에 주자 123456function slide(){ next++; console.log(next, prev); prev = next;}setInterval(slide, 1000); 콘솔창이 들어가있는 곳이 추후에 인덱스 다음과 이전 인덱스 값을 받아 처리하는 기능이 들어간다. 콘솔창을 보면 아래와 같이 다음과 이전이 1씩 밀리면서 출력된다. 123456781 0 2 1 3 2 4 3 5 4 6 5 7 6 . . . 하지만 슬라이드 갯수는 4개다. 다음 인덱스가 4 이상이 되면 0으로 초기화되도록 조건문을 입력하면 된다. 123456789function slide(){ next++; if(next &gt;= slideLength){ next = 0; }; console.log(next, prev); prev = next;}setInterval(slide, 1000); 아래와 같이 순차적으로 1씩 밀려서 출력되며, 4 이상이 되면 0으로 초기화가 된다. 123456781 0 2 1 3 2 0 3 1 0 2 1 3 2 . . . 이제 인덱스가 순차적으로 감소되는 코드를 작성해 보자 123456789function slide(){ next--; if(next &lt; 0){ next = slideLength - 1; }; console.log(next, prev); prev = next;}setInterval(slide, 1000); 다음 인덱스를 1식 빼고, 다음 인덱스가 0보다 작이질 시 슬라이드 갯수의 1을 뺀 값을 대입하면 된다. 1을 빼는 이유는 프래그래밍에서 수의 시작은 0부터 시작하기 때문이다. 네번째 슬라이드의 인덱스는 3이 될 것이다.","link":"/2017/12/15/algorithm-up-down/"},{"title":"자바스크립트 호출 스택(Call Stack)","text":"호출 스택호출 스택이란 함수의 호출을 기록하는 자료구조이다. 기본적으로 우리가 프로그램 안에서 위치한 곳이며, 만약 우리가 어떤 함수를 실행시킨다면, 우리는 스택 위에 무언가를 올리는(push) 행위를 하는 것이다. 그리고 우리가 함수로부터 반환을 받을 때, 우리는 스택의 맨 위를 가져오는(pop) 것이다. 자료구조란 사전적인 의미는 자료(Data)의 집합의 의미하며, 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것 123456789101112131415function func01() { throw new Error('Oops!');}function func02() { func01();}function func03() { func02();}func03();// Uncaught Error: Oops!// at func01 (index.html:27)// at func02 (index.html:30)// at func03 (index.html:33)// at window.onload (index.html:35) 위 코드를 실행해보면 콘솔창에 빨간 애러 스택들이 나온다. 보통 그것들은 호출 스택의 현재 상태를 나타내며, 실패함 함수를 스택처럼 위에서 아래로 나타낸다. 스택 오버플로우스택의 사이즈를 초과했을 때 발생하는 오류인데 보통 재귀를 호출했을 때 나타난다. 123456789101112131415function func() { func();}func();// Uncaught RangeError: Maximum call stack size exceeded// at foo (index.html:25)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26)// at foo (index.html:26) 엔진에서 이 코드를 실행할 때, func()에 의해서 func 함수가 호출된다. 여기서 다시 func 함수를 호출하고 반복적으로 함수를 호출하게 된다. 그러면 매번 실행할 때마다 호출스택에 func() 가 쌓이며 최대 허용치를 넘으면 위처럼 에러를 발생시킨다. References Understanding Javascript Function Executions — Call Stack, Event Loop , Tasks &amp; more자바스크립트 개발자라면 알아야 할 33가지 개념 #1 콜스택 (번역)자료구조 : 자료구조란? (Data Structure)자바스크립트의 동작원리: 엔진, 런타임, 호출 스택","link":"/2018/02/01/javascript-call-stack/"},{"title":"중첩 반복문(별찍기)","text":"중첩 반복문의 별찍기 예제이다. 알고리즘 기초 문제로 자주 등장하는 예제중 하나이다.우선 하단의 별모양으로 찍어보자 12345678910******************************************************* 나는 프로그래밍을 처음 배울때 아래처럼 코드를 작성했었다. 12345var star = '';for(var i = 0;i &lt; 10;i++){ star += '*'; console.log(star);}; *이 저장될 star를 선언한뒤 하나씩 *을 한번씩 추가한뒤 반복문이 끝나지 않고 바로 콘솔창으로 출력이 된다. 콘솔창에 10번 출력되면 되는줄 알고 왜 반복문을 중첩으로 사용해야 되지? 라는 짧은(?) 생각을 했었던 적이 있었다.반복문이 돌아갈때마다 출력이 되는것이 아닌, 구해진 값을 담아 한번에 출력해야 한다. 이렬려면 반복문이 중첩으로 사용되어야 된다. 12345678var star = '';for(var i = 0;i &lt; 10;i++){ for(var j = 0;j &lt;= i;j++){ star += '*'; }; star += '\\n';};console.log(star); 코드를 차근히 살펴 보자 외부 반복문에서 i값이 0인 상태로 내부 반복문으로 들어 간다. j가 0으로 선언되고 j와 i를 비교한다. j와 i값은 0과 0으로 같기 때문에 star에 *이 한번 대입되고 내부 반복문을 빠져 나온뒤 줄바꿈문자인 \\n을 star에 대입시킨다. 외부 반복문이 다시 실행된다. i값이 +1 되어 1인 상태에서 다시 내부함수로 들어간다. 내부반복문의 조건은 j값이 i보다 같거나 클때 실행이 된다. j값은 0으로 초기화되었기 때문에 i값이 1이므로 star에 *을 두번 대입하고 내부반복문을 빠져나오게 되고 다시 \\n을 대입하여 줄바꿈이 이루어진다. 이 과정을 반복하여 열번째 *을 대입하고 마지막으로 결과값을 콘솔창에 뿌리게 된다.콘솔창을 보면 제대로 출력된 결과물을 볼 수 있다. 여기서 응용을 하여 아래 모양으로 출력해 보자 12345************************* 별이 2개씩 추가되었다. 외부반복문의 i값이 0일때 별을 한번 찍고, 이후에는 j값이 2의 배수 일때만 내부 반복문을 실행하는 조건을 달아주면 된다. 12345678var star = '';for(var i = 0;i &lt; 10;i++){ for(var j = 0;j &lt;= (i * 2);j++){ star += '*'; }; star += '\\n';};console.log(star); 정상적으로 출력되는걸 확인할 수 있다.아래처럼 역삼각형으로 나타낼려면 어떻게 할까? 1234567891011****************************************************************** 12345678var star = '';for(var i = 10;i &gt;= 0;i--){ for(var j = 0;j &lt;= i;j++){ star += '*'; }; star += '\\n';};console.log(star); i값을 10으로 설정한 뒤 i값이 0과 같아질때까지 i값을 빼주면 된다.정상적으로 코드가 출력되는걸 확인할 수 있다. 가운데 정렬 삼각형을 만들어 보자 12345 * *** ***** **************** 5줄로 만들어진 삼각형 이다. 차근차근 살펴 보자왼쪽부터 공백이 들어가고 별은 처음 한번 찍힌 뒤 2개씩 늘어나면서 찍힌다.이제 코드를 확인해 보자 1234567891011var star = '';for(var i = 0;i &lt; 5;i++){ for(var j = 4;j &gt; i;j--){ star += ' '; }; for(var k = 0;k &lt;= (i * 2);k++){ star += '*'; }; star += '\\n';};console.log(star); 별과 공백이 대입될 star를 선언한 뒤 외부 반복문이 실행된다. 5줄인 삼각형을 만들계획이니 외부 반복문은 5번만 실행해야 된다. i값이 5보다 작을때까지만 조건을 달아주고 내부 반복문으로 들어가고, 공백이 들어갈 반복문이 첫번째로 나온다. 5줄인 삼각형이니 공백은 4칸 대입 다음에 별이 한개 대입되고, 다음에는 공백 3칸에 별 세개, 이런식으로 반복되서 마지막 5줄째에는 공백이 없고 별만 9개가 대입되도록 짜면 될 것이다. 첫번째 내부 반복문에서 공백을 star에 4번 대입하고 빠져 나온다. 두번째 내부 반복문에서는 처음 별 한개를 대입한 뒤 이후에는 2의 배수만큼 별을 대입한다. 두번째 내부 반복문을 빠져나오면 줄바꿈이 대입되고, 외부 반복문이 다섯번 반복되면 이제 콘솔창에 결과값을 출력하게 된다. 이제 위에 예제를 응용하여 다이아몬드 형태를 만들어 보도록 하자복잡한 예제인 만큼 차근차근 해석해 나가도록 하자 123456789 * *** ***** **************** ******* ***** *** * 몇줄인지 보자.. 아홉줄이다. 9번 실행되는 반복문을 먼저 선언해 주자 1234var star = '';for(var i = 0;i &lt; 9;i++){}; 별이 다섯번째 줄까지 증가하다가 그 다음부터는 감소한다. i값이 4가 될 때까지만 별을 증가시켜 주는 조건문을 달고 내부 반복문을 선언해 주자 12345678910111213var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; };};console.log(star); 12345 * *** ***** **************** 위처럼 제대로 출력된다. 이전 예제에서 해봤기 때문에 어렵지 않게 작성할 수 있다.이제 i값이 5가되면 별이 감소하는 반복문을 추가한다. 공백을 먼저 넣을 것이다. 눈으로 확인하기 쉽게 우선 공백을 - 로 표기하겠다. 123456789101112131415161718var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += '-' }; star += '\\n'; };};console.log(star); i값이 4까지만 첫번째 조건문이 실행되고 i값이 5부터는 아래 조건문이 실행된다. 2번째 조건문 반복문을 만나서 j와 i값을 비교한다. j는 4로 선언되고 i는 5 이다. j는 i보다 작다. 참이다. 공백이 한번 찍히고 다시 돌면서 비교를 한다. j는 i와 같은 값인 5가 된다. 거짓이다. 반복문을 빠져나오고 줄바꿈을 한뒤 다시 외부 반복문이 i값을 증감 한다. 이 과정을 반복하면서 아래 모양처럼 출력된다. 123456789 * *** ***** ****************---------- 이제 - 을 공백처리 한 후 별을 찍는 반복문을 추가 해 보자 123456789101112131415161718192021var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += ' ' }; for(var k = 9;k &gt; i;k--){ star += '*' }; star += '\\n'; };};console.log(star); 여기서 좀 복잡해진다. 우선 별 반쪽만 찍어보도록 해보자 123456789 * *** ***** **************** **** *** ** * 아래 조건의 반복문은 i가 5부터 8까지만 4번 실행된다.i값이 5일때 k값과 비교를 한다. k는 9죠? 참이다. 별을 한번 찍고 k값은 차례로 내려간다. k 값이 9,8,7,6이 될때까지 별을 네번 찍고 반복문을 빠져 나온다.이 과정을 거쳐 위 모양처럼 별이 출력된다. 하지만 별은 2개씩 찍혀야 된다. 조건문에 2를 곱해보자 123456789101112131415161718192021var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += ' ' }; for(var k = 9;k &gt; i * 2;k--){ star += '*' }; star += '\\n'; };};console.log(star); 12345 * *** ***** **************** 공백만 나오고 안나온다.이유는 i값이 배가 되어 k값보다 훨 씬 커지기 때문이다. 처음 비교할때 k값은 9인데 i값은 10이기 때문이다. i값의 최대치는 8인데 배가 되니 16보다 큰 수가 k값으로 대입되어야 한다. 17을 대입해 주자 123456789101112131415161718192021var star = '';for(var i = 0;i &lt; 9;i++){ if(i &lt; 5){ for(var j = 4;j &gt; i;j--){ star += ' ' }; for(var k = 0;k &lt;= i * 2;k++){ star += '*' }; star += '\\n'; }else{ for(var j = 4;j &lt; i;j++){ star += ' ' }; for(var k = 17;k &gt; i * 2;k--){ star += '*' }; star += '\\n'; };};console.log(star); k값은 17, i는 5 * 2 = 10 이다. 참이다. 별을 한번 찍고, 다시 비교, 16 &gt; 10 이다. 이과정을 네번 반복하고 계속 찍어 내려간다. 마지막 i값이 8일때 k는 17 i는 8*2 = 16 참이다. 다시 돌아서 k–은 16 이다. 16 &lt; 16 거짓이다. 반복문을 빠져 나온다. 제대로 출력되는 것을 확인할 수 있다.","link":"/2018/02/21/algorithm-star/"},{"title":"재귀 함수(Recursive Function)","text":"재귀(Recursive)를 정의한다면 한 함수가 자기 자신을 호출하는 순간이다. 재귀함수를 이해하기 전에는 팩토리얼 이라는 개념이 필요하다. 팩토리얼이란 자기 자신의 수에 1 작은 수를 곱하고 또 1 작은 수를 곱하고 해서 1 작은 수가 1이 될때까지 곱하는 것이다. 팩토리얼의 기호는 !이며 아래의 예제는 5!의 팩토리얼을 나타내고 있다. 15 * 4 * 3 * 2 * 1 = 120 이제 팩토리얼의 개념을 알았으니 재귀함수가 무엇인지 확인해 본다. 1234567function factorial(x) { if (x &lt; 0) return; if (x === 0) return 1; return x * factorial(x - 1);}factorial(3);// 6 결과 값이 나오는 과정을 순서대로 살펴보겠다. factorial 함수에 인자값으로 3을 담아 함수를 실행한다. 파라미터로 3을 받아 처음 조건문을 거친다. 3은 0보다 크기 때문에 다음 조건문으로 이동한다. 3은 0이 아니기 때문에 아래 구문으로 넘어간다. 3에 factorial 함수에 2를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 2를 넣어 실행한다. 2는 0보다 크고 0이 아니니 다시 아래 구문으로 내려간다. 2에 factorial 함수에 1를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 1를 넣어 실행한다. 1역시 0보다 크고 0이 아니니 다시 아래 구문으로 내려간다. 1에 factorial 함수에 0를 넣은 결과 값을 곱하라는 구문이다. 다시 factorial 함수에 인자로 0를 넣어 실행한다. 위와는 다르게 0은 두번째 조건문에서 걸려 1을 리턴한다. 결국은 3 * 2 * 1라는 값을 리턴하게 되는 것이다. 이렇게 함수가 자기 자신을 호출하는 순간을 재귀 라고 한다. References 재귀 함수자바스크립트 개발자라면 알아야 할 33가지 개념 #23 자바스크립트 : 자바스크립트 재귀(Recursion) 이해하기","link":"/2017/12/16/javascript-recursive/"},{"title":"switch 조건문","text":"switch키워드 오른쪽 ()안의 값과 case키워드 오른쪽의 값을 비교하여 true일시 콜론 오른쪽 구문을 실행하게 된다. 12345678var a = 0;switch (1) { case 1: console.log('ok'); break; case 2: console.log('no'); break;}// ok 조건을 만족시 구문을 실행하고, break키워드를 만나면 로직을 빠져나가게 된다. break키워드가 없을 경우 로직을 벗어나지 않고 계속 아래 조건을 읽어내려간다. 123456switch (1) { case 1: console.log('ok'); case 1: console.log('no');}// ok// no","link":"/2018/01/01/javascript-switch/"},{"title":"구구단 출력하기","text":"자바스크립트로 중첩 반복문을 활용한 구구단 출력하기 예제이다.얼마전에 코딩 테스트를 봤었는데 해당 문제가 나와 이참에 적어본다.우선 반복문으로 2단의 값을 출력해 보자 123for(var i = 1;i &lt;= 9;i++){ console.log(2 * i);}; 123452 4 6 8 . . . 정상적으로 출력된다. 이제 이 값을 하나의 변수에 넣어 보자 12345var result = '';for(var i = 1; i &lt;= 9; i++){ result += 2 * i + '\\n';};console.log(result); result에 2단의 값을 차례대로 대입하였더니 정상적으로 출력된다.이제 답 말고 구구단식도 같이 넣어 보자 12345var result = '';for(var i = 1;i &lt;= 9;i++){ result += '2' + 'x' + i + '=' + 2*i + '\\n';};console.log(result); 1234567892 x 1 = 2 2 x 2 = 4 2 x 3 = 6 2 x 4 = 8 2 x 5 = 10 2 x 6 = 12 2 x 7 = 14 2 x 8 = 16 2 x 9 = 18 조금 그럴싸해졌다.이제 중첩 반복문을 활용하여 1단부터 9단까지의 모든 구구단을 출력해 보자 123456var result = '';for(var i = 1;i &lt;= 9;i++){ for(var j = 1;j &lt;= 9;j++){ result += i + 'x' + j + '=' + i*j + '\\n'; };}; 완성이다. 로직을 살펴보자result가 선언되고 외부 반복문이 시작된다. i가 1인 상태에서 내부 반복문으로 들어간다. result에 대입되는 값을 해석해 보면 i에 문자열 x을 더하고 j값을 더한뒤 문자열 = 을 더하고 값을 더한뒤 줄바꿈 처리를 했다. 내부 반복문이 다시 실행된다. i값이 1상태에서 j는 2에서 반복문이 실행된다.i는 몇단인지 구분되는 값이 되겠다. 이런식으로 중첩되어 값을 계산하고 마지막엔 콘솔창에 값을 출력하게 된다.","link":"/2018/02/20/algorithm-multiplication/"},{"title":"자바스크립트 인덱스 구하기","text":"제이쿼리의 index()를 자바스크립트만으로 구현할 수 있다. HTML123456&lt;ul id=\"ul\"&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt; javascript123456789var ul = document.getElementById('ul'), li = ul.getElementsByTagName('li');for (var i = 0; i &lt; li.length; i++) { (function (idx) { li[idx].onclick = function () { alert(idx); } })(i);}; 결과리스트를 클릭하면 인덱스를 구할 수 있다. 0 1 2 3 var ul = document.getElementById('ul'), li = ul.getElementsByTagName('li'); for (var i = 0; i < li.length; i++) { (function (idx) { li[idx].onclick = function () { alert(idx); } })(i); };","link":"/2018/01/15/javascript-get-index/"},{"title":"while 반복문","text":"while문은 조건을 검사하여 true일경우 계속 구문을 실행시키는 반복문이다. 123while (조건) { 구문} 12345678var i = 0;while (i &lt; 3) { console.log(i); i++;}// 0// 1// 2 do-while은 whild문과 비슷하지만 처음은 조건과 상관없이 구문을 실행하고 이후에 조건을 검사하여 true일때 구문을 실행한다. 123do { 구문} while (조건) 처음 구문을 실행하여 0이 출력되고, i는 3이 아니므로 로직이 실행이 안된다. 12345var i = 0;do { console.log(i);} while (i == 3)// 0","link":"/2018/01/16/javascript-while/"},{"title":"배열 메소드","text":"자바스크립트에서 자주 쓰이는 배열 메소드 정리, 추후 계속 업데이트 예정 concat()배열을 하나로 합칠 때 사용한다. 인자로 들어온 배열의 순서대로 합쳐진다. 1234567891011var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];var arr3 = [7, 8, 9];var wrap = arr1.concat(arr2, arr2, arr3);console.log(wrap);// (12) [1, 2, 3, 4, 5, 6, 4, 5, 6, 7, 8, 9]console.log(arr1);// (3) [1, 2, 3] forEach()주어진 함수를 배열 요소 각각에 대해 실행한다. 12345678var arr = ['a', 'b', 'c'];arr.forEach(function(element){ console.log(element); // a // b // c}); map()배열을 반복하고, 콜백함수가 리턴한 값으로 새 배열을 반환한다. 1234567891011121314var users = [ { name: '철수', age: 20 }, { name: '영희', age: 25 }, { name: '민수', age: 23 }, { name: '주연', age: 27 }];var usersName = users.map(function (element) { return element.name; // 각 요소의 nama 값만 반환});console.log(usersName);// (4) [\"철수\", \"영희\", \"민수\", \"주연\"] filter()배열을 반복하고, 콜백함수의 리턴값이 true인 요소로만 구성된 새 배열을 반환한다. 아래 예제는 age가 23 초과인 요소만 반환하였다. 1234567891011121314151617var users = [ { name: '철수', age: 20 }, { name: '영희', age: 25 }, { name: '민수', age: 23 }, { name: '주연', age: 27 }];var usersOld = users.filter(function (element) { return element.age &gt; 23;});console.log(usersOld);// (2) [{…}, {…}]// 0: {name: \"영희\", age: 25}// 1: {name: \"주연\", age: 27}// length: 2// __proto__: Array(0) sort()배열을 반복하고, 콜백함수의 리턴값이 true인 요소로만 구성된 새 배열을 반환한다. 아래 예제는 age가 23 초과인 요소만 반환하였다. 123456789101112131415var arr = [5, 2, 1, 3, 10, 4];arr.sort(function(a, b){ return a - b; // 오름차순});console.log(arr);// (6) [1, 2, 3, 4, 5, 10]arr.sort(function(a, b){ return b - a; // 내림차순});console.log(arr);// (6) [10, 5, 4, 3, 2, 1] indexOf()인자로 전달된 요소와 매치되는 첫번째 요소의 인덱스를 반환한다. 일치하는 요소가 없으면 -1을 반환한다. 1234var arr = ['a', 'b', 'c', 'd'];console.log(arr.indexOf('c')); // 2console.log(arr.indexOf('e')); // -1 every()함수의 리턴값이 false가 될 때 까지 배열 요소 각각에 대해 함수를 실행한다. 123456789var arr = [1, 2, 3, 4, 5];arr.every(function(element){ console.log(element); // 1 // 2 // 3 return element &lt; 3;}); References JavaScript 배열 메소드 ( Array method )Array.prototype.forEach()알아두면 좋은 자바스크립트 배열 메소드","link":"/2018/05/15/javascript-array-method/"},{"title":"IOS 스크롤 방지","text":"모달 팝업에서 백그라운드 영역의 스크롤을 방지하고자 할 때 Android는 body에 “overflow: hidden” 속성만 줘도 스크롤이 방지되지만 IOS의 경우는 먹히지 않는다.이럴 경우 body를 “position: fixed” 로 고정시킨 뒤 스크롤, 터치, 마우스휠 이벤트를 막아버리면 된다. 12345.scrollOff { position: fixed; overflow: hidden; height: 100%;} 1234567// ios 스크롤 방지$('body').addClass('scrollOff').on('scroll touchmove mousewheel', function(e){ e.preventDefault();});// ios 스크롤 방지$('body').removeClass('scrollOff').off('scroll touchmove mousewheel');","link":"/2018/06/11/ios-scroll-off/"},{"title":"정규표현식","text":"정규표현식은 문자열에 포함된 문자 조합을 찾기 위해 사용되거나 그 문자열을 다른 문자열로 치환해 주는 패턴이다. 예를 들면 회원가입 화면에서 사용자로 부터 입력받는 전화번호가 유효한지 체크할 필요가 있을 때 정규표현식을 사용하면 간단하게 처리할 수 있다. 1234var tel = '0101234567팔';var regExp = /^[0-9]+$/;console.log(regExp.test(tel)); // false 정규표현식은 하나의 언어라고 할 만큼 모든것을 다루기에는 너무 방대하다. 정규표현식 패턴은 zvon의 정규표현식 tutorials에서 확인할 수 있다. 정규표현식은 리터럴 표기법과 생성자 함수로 생성할 수 있다. 리터널 방식1var re = /ab + c/; 리터널 방식은 스크립트가 불어와질 때 컴파일 된다. 정규직이 상수라면 이렇게 사용하는 것이 성능을 향상시킨다. 생성자 함수 방식1var re = new RegExp(\"ab + c\"); 생성자 함수 방식은 정규식이 실행 시점에 컴파일 된다. 정규식의 패턴이 변경될 수 있는 경우, 혹은 사용자 입력과 같이 다른 출처로부터 패턴을 가져와야 하는 경우에 생성자 함수 방식을 쓴다. 정규 표현식 리터럴은 아래와 같이 표현한다. 1var re = /pa/i; / 는 시작, 종료기호 이며, pa는 패턴, i는 프래그 이다. 자바스크립트에서 정규표현식 패턴들은 RegExp의 exec 메소드와 test 메소드, 그리고 String의 match메소드, replace메소드, search메소드, split 메소드와 함께 쓰인다. 메소드 설명 RegExp.exec() 어떤 문자열에서 정규표현식과 일치하는 문자열 검색을 수행한다. 결과로 배열을 리턴하거나 null을 반환한다. RegExp.test() 대상 문자열 속에 일치하는 문자열이 포함되어 있는지 검사하고 true 또는 false를 반환한다. String.match() 문자열이 정규식과 매치되는 부분을 검색한다. String.replace() 대응되는 문자열을 찾아 다른 문자열로 치환하는 String 메소드이다. String.search() 대응되는 문자열이 있는지 검사하는 String 메소드 이다. 대응된 부분의 인덱스를 반환한다. 대응되는 문자열을 찾지 못했다면 -1을 반환한다. String.split() 정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 String 메소드이다. 123456789101112var str = 'this is a pen.';var regexr = /is/ig;// RegExp 객체의 메소드console.log(regexr.exec(str)); // [\"is\", index: 2, input: \"this is a pen.\", groups: undefined]console.log(regexr.test(str)); // true// String 객체의 메소드console.log(str.match(regexr)); // (2) [\"is\", \"is\"]console.log(str.replace(regexr, 'is')); // this is a pen.console.log(str.search(regexr)); // 2console.log(str.split(regexr)); // (3) [\"th\", \" \", \" a pen.\"] References 정규표현식5.26 RegExp 정규표현식정규 표현식","link":"/2018/03/02/javascript-regexp/"},{"title":"생성자 함수에서의 This","text":"객체를 생성하는 방법은 크게 객체 리터널 방식과 생성자 함수 방식, Object() 생성자 함수 방식이 있다. 123var obj = {};var obj = new Func();var obj = new Object(); 이 세가지 중 생성자 함수의 this를 알아보겠다. 생성자 함수는 기존 함수에 new 키워드를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 일반 함수에서의 this는 window를 가르키지만 생성자 함수에서는 다르게 동작한다. 이때문에 원치 않은 상황이 나타날 수 있는데, 이를 피하기 위해 생성자 함수 이름의 첫 글자는 대문자로 작성하기를 권장하고 있다. 일반 함수의 this1234function func(){ console.log(this);};func(); // window 생성자 함수의 this1234567function Func(name){ this.name = name; console.log(this); return this;};var obj = new Func(\"foo\");console.log(obj); // Func {name: \"foo\"} 생성자 함수의 this 는 메서드 함수 호출과의 this 바인딩과 다르게 동한다. 이를 이해하려면 생성자 함수가 어떻게 동작하는지 알아야 한다. 위의 코드를 보면 생성자 함수가 정의되었고 인자값으로 name 프로퍼티의 값을 받고 있다. new 키워드를 사용해서 생성자 함수를 호출하면 우선 빈 객체가 생성되고, 이 객체는 생성자 함수의 프로토타입을 참조한다. 생성자 함수가 실행되면서 동적으로 name 프로퍼티를 추가시킨다. this로 바인딩한 객체가 생성자 함수의 리턴값으로 반환되서 obj 변수에 저장된다.","link":"/2018/11/02/javascript-constructor-this/"},{"title":"자바스크립트에서의 This","text":"this는 함수가 호출되면 함수 내부로 암묵적으로 전달된다.this는 메서드를 호출한 객체가 저장되어 있는 속성이다.메서드 뿐만 아니라 일반 함수를 호출할때도 만들어 지며, 이벤트 리스너가 호출될 때에도 만들어진다. 문제는 this 속성에 저장되는 값이 동일한 값이 아니라 각각 다른점이다. this가 만들어지는 경우 일반 함수에서의 this 중첩 함수에서의 this 이벤트 리스너에서의 this 메서드에서의 this 메서드 내부의 중첩 함수의 this 일반 함수에서의 this1234function func(){ console.log(this); // window};func(); 일반 함수 내부에서는 this는 전역객체인 window가 된다. 자바스크립트의 모든 전역 변수는 전역객체의 프로퍼티이다. 중첩 함수에서의 this1234567function func(){ function func2(){ console.log(this); // window }; func2();};func(); 일반 중첩 함수에서의 this 도 window 가 된다. 이벤트 리스너에서의 this12345window.onload = function(){ document.getElementById(\"btn\").addEventListener(\"click\", function(){ console.log(this); });}; 이벤트 리스너에서의 this는 이벤트를 발생시킨 객체가 된다. 메서드에서의 this123456var obj = { func: function(){ console.log(this); // object{}; }};obj.func(); 메서드에서의 this는 이벤트를 발생시킨 객체가 된다. 메서드 내부의 중첩 함수의 this123456789var obj = { func: function(){ function func2(){ console.log(this); // window }; func2(); }};obj.func(); 메서드의 this 와는 다르게 window 를 가리킨다. 이는 내부 함수 호출 패턴을 정의해 놓지 않기 때문이다. 내부함수도 결국 함수이므로 이를 호출할 때는 함수 호출로 취급된다.중첩함수가 메서드를 포함한 객체를 참조하려면 부모함수의 this를 내부함수가 접근 가능한 변수에 저장하면 된다.보통 관례상 this 값을 저장하는 변수의 이름을 that 이라고 선언한다. 12345678910var obj = { func: function(){ var that = this; function func2(){ console.log(that); // window }; func2(); }};obj.func(); 자바스크립트는 위와 같은 바인딩의 한계를 극복하려고 this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공한다.제이쿼리 등 자바스크립트 라이버리들의 경우 bind 라는 메서드를 통해, 사용자가 원하는 객체를 this에 바인딩 하는 기능을 제공하고 있다.","link":"/2018/11/01/javascript-this/"},{"title":"함수 메소드(call, apply, bind)","text":"함수의 기본 메소드중 call, apply, bind 에 대해 알아보자 자바스크립트에서 상속개념을 자주 쓰다보면 불필요한 메소드에 프로토타입까지 상속받아 오기 때문에 메모리 낭비가 심해진다. 이때 다른 객체의 메소드를 가져와 쓸 수 있는데 그 기능을 가진 메소드가 call과 apply 이다. call 메소드 먼저 살펴보겠다. call12345func.call(obj, a, b);func = 가져올 메소드call = call 메소드obj = 메소드를 사용할(현재) 객체a, b = 메소드에 전달할 인자 1234567var obj1 = { name: \"obj1\", funcThis: function(){ return this; }};console.log(obj1.funcThis()); // Object {name: \"obj1\"} obj1 객체에 funcThis 메소드를 추가했다. funcThis 메소드는 자신을 감싼 obj1객체를 리턴하고 있다. 12345678910var obj1 = { name: \"obj1\", funcThis: function(){ return this; }};var obj2 = { name: \"obj2\"};console.log(obj1.funcThis.call(obj2)); // Object {name: \"obj2\"} call 메소드를 이용하여 obj1 의 funcThis 메소드를 obj2 객체에서 실행한다. obj2객체를 리턴하고 있다. 아무 값을 안넣으면(null) window를 반환한다. call 과 형제격인 apply 메소드는 call 메소드와 같지만 한가지 다른점이 있다. call은 인자값을 하나 하나 전달하지만 apply 메소드는 인자값을 배열로 전달한다. apply12345func.apply(obj, [arr]);func = 가져올 메소드apply = apply 메소드obj = 메소드를 사용할(현재) 객체arr = 메소드에 전달할 인자 목록 call 과 apply 는 보통 함수 내 arguments 객체와 같이 사용하는 모습을 많이 볼 수 있다. 처음에는 어려워 보이지만, 단순하게 보면 결국 arguments 객체에 다른 메소드를 빌려와 쓰는것으로 보면 된다. arguments 객체는 배열처럼 보이지만 실제 배열이 아닌 유사배열객체이기 때문에 배열 메소드가 없다(length 제외). 아래 구문은 arguments에 없는 배열의 메소드를 가져와 쓰는 것이다. 1234function func(){ console.log(Array.prototype.slice.call(arguments, 0, 2));};func(\"눈\", \"누\", \"난\", \"나\"); // [\"눈\", \"누\"] 위 함수를 보면 배열의 프로토타입에 있는 slice 메소드를 arguments 객체에서 사용하는 것을 알 수 있다. 12345slice 메소드 : 문자열의 일정 부분을 반환obj.slice(start, end);obj = 필수. 반환할 배열 객체start = 필수. 지정된 부분의 시작입start = 선택. 지정된 부분의 끝 1234function func(){ console.log(Array.prototype.join.call(arguments));};func(\"눈\", \"누\", \"난\", \"나\"); // 눈-누-난-나 join 메소드 : 인자값으로 넘겨진 구문을 모든 배열 요소에 추가한다. 123obj.join(&quot;val&quot;);obj = 필수. 반환할 배열 객체val = 선택. 추가할 문자열 이다. 아무값도 안넣을 경우 쉼표(,)로 대체된다. bindbind 함수는 함수가 가르키는 this만 바꾸고 호출은 하지 않는다. 1234567891011var obj1 = { name: \"obj1\", funcThis: function(){ console.log(this); }};var obj2 = { name: \"obj2\"};var func = obj1.funcThis.bind(obj2);func(); // Object {name: \"obj2\"} obj1 의 funcThis 메서드를 obj2 객체로 가져와서 func 변수에 할당했다. func 함수를 실행하면 obj2 객체가 출력된다.","link":"/2018/11/08/javascript-function-method/"},{"title":"var, let, const 차이","text":"var는 변수를 선언하는 키워드이며, ES6부터 let과 const가 추가되었다.var는 함수 스코프를 가지고 let과 const는 블록 스코프를 가진다. 여기서 스코프란 코드가 실행되는 유효범휘이다. 블록 스코프블록 스코프는 중괄호{}로 감싸진 범위를 말한다. 아래는 조건문(if), 반복문(for), 함수(function)가 블록 스코프를 가지고 있는 모습이다. 1234567891011if (true) { // 블록 스코프}for (var i = 0; i &lt; 10; i++) { // 블록 스코프}function func() { // 블록 스코프} var기존의 var는 위 세개중 함수에서만 스코프를 가진다. 1234567891011121314151617if (true) { var a = 1;}console.log(a);// 1for (var i = 0; i &lt; 1; i++) { var b = 2;}console.log(b);// 2function func() { var c = 3;}console.log(c);// Uncaught ReferenceError: foo is not defined at window.onload var는 중복 선언이 가능하다. 1234var a = 1; a = 2;console.log(a);// 2 let, constES6부터 추가된 let, const는 조건문과 반복문에도 스코프를 가진다. 12345678910111213141516171819202122232425262728293031if (true) { let a = 1; const b = 2; console.log(a); // 1 console.log(B); // 2}console.log(a);// Uncaught ReferenceError: a is not defined at window.onloadconsole.log(b);// Uncaught ReferenceError: a is not defined at window.onloadfor (var i = 0; i &lt; 1; i++) { let c = 3; const d = 4; console.log(c); // 3 console.log(d); // 4}console.log(c); // Uncaught ReferenceError: a is not defined at window.onloadconsole.log(d); // Uncaught ReferenceError: a is not defined at window.onloadfunction func() { let e = 5; const f = 6; console.log(e); // 5 console.log(f); // 6}func();console.log(e);// Uncaught ReferenceError: foo is not defined at window.onloadconsole.log(f);// Uncaught ReferenceError: foo is not defined at window.onload let과 const의 차이는 const 가 좀 더 엄격하다. let은 중복선언이 되지만 const는 중복선언이 안되기 때문에 변수가 선언될 때 값을 할당하여야 한다. const는 DB환경정보, API응답값 등 변하지 않을 값을 담을 때 사용한다. 12345678let a; a = 1;console.log(a);// 1const b; b = 2;// Uncaught TypeError: Assignment to constant variable. 결론 var은 함수 스코프에서만 유효 let, const는 블록 스코프에서 유효 const는 선언과 동시에 할당이 일어나야하고, 재할당이 불가 References 자바스크립트 변수와 스코프(유효범위)","link":"/2019/06/05/javascript-block-scope/"},{"title":"프로토타입(Prototype)","text":"자바스크립트는 클래스라는 개념이 없다. 클래스는 자바, 파이썬, 루바 등 객체지향 언어에서 빠질수 없는 개념이다. 하지만 자바스크립트도 객체지향언어인데, 클래스 대신 프로토타입(Prototype)을 기반으로 클래스의 상속 기능을 흉내내도록 구현하여 사용한다. 그래서 자바스크립트는 프로토타입 기반의 객체 지향 언어라고 한다. 자바스크립트의 모든 객체는 자신의 부모역할을 담당하는 객체와 연결되어 있다. 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 프로토타입 이라 한다. 프로토타입은 언제 쓰는가123456789101112function Person() { this.eyes = 2; this.nose = 1;}var kang = new Person();var park = new Person();console.log(kang.eyes); // 2console.log(kang.nose); // 1console.log(park.eyes); // 2console.log(park.nose); // 1 kang과 park은 eyes와 nose를 공통적으로 가지고 있는데, 메모리는 eyes와 nose가 두개씩 총 4개에 할당된다. 객체를 100개를 만들면 200개의 변수가 메모리에 할당된다. 이런 메모리 낭비 문제를 프로토타입으로 해결할 수 있다. 12345678910function Person() {}Person.prototype.eyes = 2;Person.prototype.nose = 1;var kang = new Person();var park = new Person();console.log(kang.eyes); // 2console.log(park.nose); // 1 간략히 설명하면 Person.prototype라는 빈 객체가 어딘가에 존재하고 Person함수로부터 생성된 객체(kang, park)은 어딘가에 존재하는 객체의 값을 모두 갖다쓸 수 있다. 즉, eyes와 nose를 어딘가에 있는 빈 객체(Person.prototype)에 넣어두고, kim과 park이 공유해서 사용하는 것이다. 프로토타입 객체와 프로토타입 링크자바스크립트에서는 프로토타입 객체(prototype object)와 프로토타입 링크(prototype link)라는 것이 존재한다. 그리고 이 둘을 통틀어 프로토타입이라고 부른다. 객체는 언제나 함수로 생성된다.12function Person() {} // 함수var obj = new Person(); // new 키워드와 함수로 객체를 생성 obj 객체는 Person이라는 함수로 생성된 객체이다. 일반적인 객체 리터럴 방식도 예외는 아니다. 1var obj = {}; 객체 리터럴 방식으로 객체를 생성하였는데 이 방식은 아래 방식과 같다. 1var obj = new Object(); Object도 객체를 만드는 생성자 함수이다. Object와 마찬가지로 Function, Array도 모두 생성자 함수이다. 이 사실은 프로토타입과 밀접하게 관련이 있는데 함수가 정의될 때는 2가지 일이 동시에 일어나기 때문이다. 함수가 정의될 때1. 해당 함수에 constructor(생성자) 자격 부여constructor 자격이 부여되면 new 키워드를 통해 객체를 만들수 있다. 오직 함수만 new 키워드를 사용할 수 있다. 123var obj = {}; // 객체 선언var a = new obj();// Uncaught TypeError: obj is not a constructor obj는 생성자 자격이 없다고 나온다. 오직 함수만이 constructor 자격을 가질 수 있다. 2. 해당 함수의 프로토타입 객체 생성 및 연결함수를 정의하면 함수만 생성되는 것이 아니라 프로토타입 객체도 같이 생성이 된다. 생성된 함수는 prototype라는 속성을 통해 프로토타입 객체에 접근할 수 있다. 프로토타입 객체는 일반적인 객체와 같으며, 기본적인 속성으로 constructor와 __proto__를 가지고 있다. 12345function Person() {}console.log(Person.prototype);// {constructor: ƒ}// &gt; constructor: ƒ Person()// &gt; __proto__: Object constructor는 프로토타입 객체와 같이 생성되었던 함수를 가르키고 있다. __proto__은 프로토타입 링크다. 프로토타입 링크는 아래에서 다시 알아보도록 하고 위에서 언급된 eyes, nose예제를 다시 살펴보겠다. 1234567891011121314function Person() {}Person.prototype.eyes = 2;Person.prototype.nose = 1;var kang = new Person();var park = new Person();console.log(Person.prototype);// {eyes: 2, nose: 1, constructor: ƒ}// &gt; eyes: 2// &gt; nose: 1// &gt; constructor: ƒ Person()// &gt; __proto__: Object Person.prototype라는 빈 객체가 어딘가에 존재하고, 그 객체에 eyes, nose값을 할당한 것을 확인할 수 있다. 프로토타입 객체는 일반적인 객체이므로 속성을 마음대로 추가, 삭제할 수 있으며 kang과 park은 Person함수를 통해 생성되었으니 Person.prototype를 참조할 수 있게 된다. 프로토타입 링크12345678function Person() {}Person.prototype.eyes = 2;var kang = new Person();console.log(kang);// Person {}console.log(kang.eyes);// 2 kang객체에 따로 eyes속성을 선언하지 않았지만 kang.eyes를 실행하면 2라는 값을 참조한다. 위에서 설명했듯이 프로토타입 객체의 eyes속성을 참조한 것인데, 이것이 가능한 이유는 kang이 가지고 있는 __proto__속성이 프로토타입 객체를 가르키고 있기 때문이다. 12console.log(kang.__proto__);// {eyes: 2, nose: 1, constructor: ƒ} kang.__proto__ 속성을 확인해보니 프로토타입 객체를 가르키고 있다. kang객체는 직접 eyes속성을 가지고 있지 않아 eyes속성을 찾을 때 까지 상위 프로토타입을 탐색한다. 최상위인 Object의 프로토타입 객체까지 도달했는데도 못찾을 경우 undefined를 리턴한다. 이렇게 __proto__속성을 통해 상위 프로토타입과 연결되어있는 형태를 프로토타입 체인이라고 한다. 이런 프로토타입 체인 구조 때문에 모든 객체는 Object의 자식이라고 하며, Object에 있는 모드 속성을 사용할 수 있다. References [Javascript ] 프로토타입 이해하기Javascript 기초 - Object prototype 이해하기JavaScript : 프로토타입(prototype) 이해","link":"/2018/12/17/javascript-prototype/"},{"title":"탭메뉴(tab menu)","text":"vanilla JS로 제작된 기본 탭 메뉴 구현 window.addEventListener('load', function(){ var tab = document.getElementById('tab'), btn = tab.getElementsByClassName('btn')[0], cnt = tab.getElementsByClassName('cnt')[0], index = 0; btn.children[0].classList.add('on'); cnt.children[0].classList.add('on'); for(var i = 0;i < btn.children.length;i++){ (function(target){ btn.children[target].addEventListener('click', function(){ tabOn(target); }); })(i); }; function tabOn(target){ for(var i = 0;i < btn.children.length;i++){ btn.children[i].classList.remove('on'); cnt.children[i].classList.remove('on'); }; btn.children[target].classList.add('on'); cnt.children[target].classList.add('on'); } }); .uiWrap * { margin: 0; padding: 0; } .uiWrap ul li:before, .uiWrap ol li:before { display:none; } #tab { border: 1px solid #ccc; width: 400px; } #tab .btn:after { content: ''; display: block; clear: both; } #tab .btn button { float: left; border: 0; width: 25%; height: 30px; cursor: pointer; outline: none; background-color: #ccc; } #tab .btn button:hover { background-color: #fff; } #tab .btn button.on { background-color: #fff; } #tab .cnt div { display: none; } #tab .cnt div.on { display: block; } 01 02 03 04 content01 content01 content01 content01 content01 content01 content01 content01 content01 content01 content02 content02 content02 content02 content02 content02 content02 content02 content02 content02 content03 content03 content03 content03 content03 content03 content03 content03 content03 content03 content04 content04 content04 content04 content04 content04 content04 content04 content04 content04 HTML1234567891011121314&lt;div id=\"tab\"&gt; &lt;div class=\"btn\"&gt; &lt;button type=\"button\"&gt;01&lt;/button&gt; &lt;button type=\"button\"&gt;02&lt;/button&gt; &lt;button type=\"button\"&gt;03&lt;/button&gt; &lt;button type=\"button\"&gt;04&lt;/button&gt; &lt;/div&gt; &lt;div class=\"cnt\"&gt; &lt;div&gt;content01 content01 content01 content01 content01 content01 content01 content01 content01 content01&lt;/div&gt; &lt;div&gt;content02 content02 content02 content02 content02 content02 content02 content02 content02 content02&lt;/div&gt; &lt;div&gt;content03 content03 content03 content03 content03 content03 content03 content03 content03 content03&lt;/div&gt; &lt;div&gt;content04 content04 content04 content04 content04 content04 content04 content04 content04 content04&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536#tab { border: 1px solid #ccc; width: 400px;}#tab .btn:after { content: ''; display: block; clear: both;}#tab .btn button { float: left; border: 0; width: 25%; height: 30px; cursor: pointer; outline: none; background-color: #ccc;}#tab .btn button:hover { background-color: #fff;}#tab .btn button.on { background-color: #fff;}#tab .cnt div { display: none;}#tab .cnt div.on { display: block;} javascript12345678910111213141516171819202122232425262728window.addEventListener('load', function(){ var tab = document.getElementById('tab'), btn = tab.getElementsByClassName('btn')[0], cnt = tab.getElementsByClassName('cnt')[0], index = 0; btn.children[0].classList.add('on'); cnt.children[0].classList.add('on'); for(var i = 0;i &lt; btn.children.length;i++){ (function(target){ btn.children[target].addEventListener('click', function(){ tabOn(target); }); })(i); }; function tabOn(target){ for(var i = 0;i &lt; btn.children.length;i++){ btn.children[i].classList.remove('on'); cnt.children[i].classList.remove('on'); }; btn.children[target].classList.add('on'); cnt.children[target].classList.add('on'); }});","link":"/2019/04/08/ui-tab-menu/"},{"title":"슬라이드 배너(slide banner))","text":"vanilla JS로 만들어본 기본 슬라이드 배너 플러그인 없이 자바스크립트만 활용 다음, 이전 버튼으로 슬라이드 조작 가능 인디게이터는 슬라이드 갯수에 맞게 자동으로 생성 자동재생, 일시정지 버튼으로 웹 접근성 준수 구현 window.addEventListener('load', function(){ var MOVEING_PX = 4, AUTO_TIME = 2000, slide = document.getElementById('slide'), indi = document.createElement('ul'), slideCnt = slide.getElementsByClassName('cnt'), slideCntItem = slideCnt[0].getElementsByTagName('li'), prevBtn = slide.getElementsByClassName('prev'), nextBtn = slide.getElementsByClassName('next'), playBtn = slide.getElementsByClassName('play'), stopBtn = slide.getElementsByClassName('stop'), playSet = null, before = 0, after = 0, moveIng = false; // init slideCntItem[0].style.left = 0; playBtn[0].style.display = 'block'; var indi = document.createElement('ul'); for(var i = 0;i < slideCntItem.length;i++){ indi.innerHTML += ''; }; indi.classList.add('indi'); indi.children[0].classList.add('on'); slide.append(indi); for(var j = 0;j < indi.children.length;j++){ indiClick(j); }; // initEvnet nextBtn[0].addEventListener('click', function(e){ if(!moveIng){ after++; if(after >= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }); prevBtn[0].addEventListener('click', function(e){ if(!moveIng){ after--; if(after < 0){ after = slideCntItem.length - 1; }; move(after, before); before = after; }; }); playBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'none'; stopBtn[0].style.display = 'block'; playSet = setInterval(function(){ if(!moveIng){ after++; if(after >= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }, AUTO_TIME); }); stopBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'block'; stopBtn[0].style.display = 'none'; clearInterval(playSet); }); function indiClick(target){ indi.children[target].addEventListener('click', function(){ if(!moveIng){ after = target; if(after > before){ move(after, before, 'next'); }else if(after < before){ move(after, before); }; before = after; }; }); } function move(after, before, type){ var nextX = type === 'next' ? slide.offsetWidth : slide.offsetWidth * -1, prevX = 0, set = null; set = setInterval(function(){ moveIng = true; if(type === 'next'){ nextX -= MOVEING_PX; slideCntItem[after].style.left = nextX + 'px'; if(nextX = 0){ clearInterval(set); nextX = slide.offsetWidth * -1; moveIng = false; }; prevX += MOVEING_PX; }; slideCntItem[before].style.left = prevX + 'px'; }); indi.children[before].classList.remove('on'); indi.children[after].classList.add('on'); } }); .uiWrap * { margin: 0; padding: 0; } .uiWrap ul li, .uiWrap ol li { list-style: none; } .uiWrap ul li:before, .uiWrap ol li:before { display: none; } #slide { position: relative; overflow: hidden; width: 400px; height: 300px; } #slide .cnt>li { position: absolute; top: 0; left: 400px; margin: 0; width: 400px; height: 300px; text-align: center; font-size: 30px; line-height: 300px; color: #fff; } #slide .cnt>li:nth-child(1) { background-color: red; } #slide .cnt>li:nth-child(2) { background-color: orange; } #slide .cnt>li:nth-child(3) { background-color: green; } #slide .cnt>li:nth-child(4) { background-color: blue; } #slide .btn>button { position: absolute; top: 50%; transform: translateY(-50%); border: 0; padding: 5px; background-color: #fff; } #slide .btn .prev { left: 5px; } #slide .btn .next { right: 5px; } #slide .auto>button { display: none; position: absolute; bottom: 5px; right: 5px; border: 0; padding: 5px; background-color: #fff; } #slide .indi { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); margin: 0; } #slide .indi:after { content: ''; display: block; clear: both; } #slide .indi>li { float: left; margin: 0 0 0 5px; border-radius: 50%; width: 12px; height: 12px; cursor: pointer; opacity: .5; background-color: #fff; } #slide .indi>li.on { opacity: 1 } #slide .indi>li:first-child { margin-left: 0 } 1 2 3 4 prev next stop play HTML12345678910111213141516&lt;div id=\"slide\"&gt; &lt;ul class=\"cnt\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"btn\"&gt; &lt;button type=\"button\" class=\"prev\"&gt;prev&lt;/button&gt; &lt;button type=\"button\" class=\"next\"&gt;next&lt;/button&gt; &lt;/div&gt; &lt;div class=\"auto\"&gt; &lt;button type=\"button\" class=\"stop\"&gt;stop&lt;/button&gt; &lt;button type=\"button\" class=\"play\"&gt;play&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#slide { position: relative; overflow: hidden; width: 400px; height: 300px;}#slide .cnt&gt;li { position: absolute; top: 0; left: 400px; width: 400px; height: 300px; text-align: center; font-size: 30px; line-height: 300px; color: #fff;}#slide .cnt&gt;li:nth-child(1) { background-color: red;}#slide .cnt&gt;li:nth-child(2) { background-color: orange;}#slide .cnt&gt;li:nth-child(3) { background-color: green;}#slide .cnt&gt;li:nth-child(4) { background-color: blue;}#slide .btn&gt;button { position: absolute; top: 50%; transform: translateY(-50%); border: 0; padding: 5px; background-color: #fff;}#slide .btn .prev { left: 5px;}#slide .btn .next { right: 5px;}#slide .auto&gt;button { display: none; position: absolute; bottom: 5px; right: 5px; border: 0; padding: 5px; background-color: #fff;}#slide .indi { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%)}#slide .indi:after { content: ''; display: block; clear: both;}#slide .indi&gt;li { float: left; margin-left: 5px; border-radius: 50%; width: 12px; height: 12px; cursor: pointer; opacity: .5; background-color: #fff;}#slide .indi&gt;li.on { opacity: 1}#slide .indi&gt;li:first-child { margin-left: 0} javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122window.addEventListener('load', function(){ var MOVEING_PX = 4, AUTO_TIME = 2000, slide = document.getElementById('slide'), indi = document.createElement('ul'), slideCnt = slide.getElementsByClassName('cnt'), slideCntItem = slideCnt[0].getElementsByTagName('li'), prevBtn = slide.getElementsByClassName('prev'), nextBtn = slide.getElementsByClassName('next'), playBtn = slide.getElementsByClassName('play'), stopBtn = slide.getElementsByClassName('stop'), playSet = null, before = 0, after = 0, moveIng = false; // init slideCntItem[0].style.left = 0; playBtn[0].style.display = 'block'; var indi = document.createElement('ul'); for(var i = 0;i &lt; slideCntItem.length;i++){ indi.innerHTML += '&lt;li&gt;&lt;/li&gt;'; }; indi.classList.add('indi'); indi.children[0].classList.add('on'); slide.append(indi); for(var j = 0;j &lt; indi.children.length;j++){ indiClick(j); }; // initEvnet nextBtn[0].addEventListener('click', function(e){ if(!moveIng){ after++; if(after &gt;= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }); prevBtn[0].addEventListener('click', function(e){ if(!moveIng){ after--; if(after &lt; 0){ after = slideCntItem.length - 1; }; move(after, before); before = after; }; }); playBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'none'; stopBtn[0].style.display = 'block'; playSet = setInterval(function(){ if(!moveIng){ after++; if(after &gt;= slideCntItem.length){ after = 0; }; move(after, before, 'next'); before = after; }; }, AUTO_TIME); }); stopBtn[0].addEventListener('click', function(){ playBtn[0].style.display = 'block'; stopBtn[0].style.display = 'none'; clearInterval(playSet); }); function indiClick(target){ indi.children[target].addEventListener('click', function(){ if(!moveIng){ after = target; if(after &gt; before){ move(after, before, 'next'); }else if(after &lt; before){ move(after, before); }; before = after; }; }); } function move(after, before, type){ var nextX = type === 'next' ? slide.offsetWidth : slide.offsetWidth * -1, prevX = 0, set = null; set = setInterval(function(){ moveIng = true; if(type === 'next'){ nextX -= MOVEING_PX; slideCntItem[after].style.left = nextX + 'px'; if(nextX &lt;= 0){ clearInterval(set); nextX = slide.offsetWidth; moveIng = false; }; prevX -= MOVEING_PX; }else{ nextX += MOVEING_PX; slideCntItem[after].style.left = nextX + 'px'; if(nextX &gt;= 0){ clearInterval(set); nextX = slide.offsetWidth * -1; moveIng = false; }; prevX += MOVEING_PX; }; slideCntItem[before].style.left = prevX + 'px'; }); indi.children[before].classList.remove('on'); indi.children[after].classList.add('on'); }});","link":"/2019/04/10/ui-slide-banner/"},{"title":"Web Technology Terminology","text":"틈틈히 웹 관련 용어를 정리하는 곳 용어 설명 dump 프로그램 디버그 또는 시스템 테스트의 목적을 위해 기록되는 파일 temp 임시 폴더","link":"/2019/03/25/web-technology-terminology/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"ui, vanillaJs","slug":"ui-vanillaJs","link":"/tags/ui-vanillaJs/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"jQuery","slug":"jQuery","link":"/categories/jQuery/"},{"name":"ui","slug":"ui","link":"/categories/ui/"}]}