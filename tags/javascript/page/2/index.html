<!doctype html>
<html lang="ko"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>태그: javascript - 기록맨</title><meta property="og:type" content="blog"><meta property="og:title" content="기록맨"><meta property="og:url" content="https://recordboy.github.io/"><meta property="og:site_name" content="기록맨"><meta property="og:locale" content="ko_KR"><meta property="article:author" content="recordboy"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://recordboy.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://recordboy.github.io"},"headline":"기록맨","image":["https://recordboy.github.io/img/og_image.png"],"author":{"@type":"Person","name":"recordboy"},"description":""}</script><link rel="icon" href="/img/logo.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="기록맨" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="검색" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">태그</a></li><li class="is-active"><a href="#" aria-current="page">javascript</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-04T02:42:45.000Z" title="2020-02-04T02:42:45.000Z">2020-02-04</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">5분 읽기 (대략 772 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/04/javascript-singleton-pattern/">자바스크립트 싱글톤 패턴</a></h1><div class="content"><p>전체 시스템에서 하나의 인스턴스만 존재하도록 보장하는 객체 생성패턴을 의미한다. 대표적으로 $를 활용해서 DOM을 조작하고 이벤트도 다루는 jQuery가 있으며, 객체 리터럴도 싱글톤 패턴이라고 할수 있다.(자바스크립트에서 객체 리터럴로 생성한 객체는 다른 객체와 같을 수 없다. 객체 내부의 내용이 같더라도 참조하는 객체가 다르기 때문이다.)</p>
<p>객체 리터널은 한계가 있는데 비공개 프로퍼티 및 함수를 선언할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'myName'</span>,</span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.get()); <span class="comment">// myName</span></span><br></pre></td></tr></table></figure>

<p>비공개 프로퍼티 및 함수를 정의하려면 클로저(closure)를 활용해야 한다. 즉 제대로 된 싱글톤 패턴은 객체 리터널 + 클로저의 조합이 필요하다고 할 수 있다. 아래 코드를 확인해보면</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 비공개 프로퍼티 정의</span></span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 비공개 메서드 정의</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// singleton 인스턴스 정의</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 공개 프로퍼티 정의</span></span><br><span class="line">            prop: <span class="string">'value'</span>,</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 공개 메서드 정의</span></span><br><span class="line">            method: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 공개 메서드인 getInstance를 정의한 객체, 비공개 프로퍼티 및 메서드에 접근 가능(클로저)</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">        getInstance: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 인스턴스가 선언이 안되있는경우 인스턴스 생성</span></span><br><span class="line">            <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">                instance = init();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 인스턴스가 선언이 되있는 경우 인스턴스 반환</span></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton1 = singleton.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(singleton1.method());</span><br><span class="line"><span class="keyword">var</span> singleton2 = singleton.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(singleton1 === singleton2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>위 코드는 비공개 메서드인 init()의 return문에서 객체 리터럴로 정의되는 인스턴스가 싱글톤 객체이며, 전체 시스템에서 하나만 존재하게 된다. 순서대로 보면 익명함수의 return문에는 싱글톤 객체를 구하는 공개 메서드(getInstance)를 포함한 객체를 반환하며, getInstance메서드는 instance값을 확인해 인스턴스가 선언이 안되있는 경우 비공개 메서드인 init를 호출하여 singleton인스턴스를 생성하여 instance에 할당하게 된다. 이렇게 일반적으로 싱글톤 패턴에서는 이미 객체가 생성되었는지 여부를 알려주는 instance와 같은 내부 변수가 필요하다. 그리고 싱글톤 패턴에서는 내부 변수에 접근할 수 있는 객체를 반환하는 클로저를 이용해야 한다.</p>
<p>정리를 하면 내부의 getInstance메서드에서 비공개 프로퍼티인 instance에 접근할 수 있다는 것과, getInstance메서드의 호출이 끝나더라도 instance의 값은 계속 유지되는 특성(클로저)를 이용해 prop, method()이 포함된 객체를 유일하게 생성하게 된다. 그래서 singleton.getInstance()를 몇번이나 호출하더라도 얻는 객체는 모두 동일한 싱글톤 객체를 가리키게 된다.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p><a href="https://webclub.tistory.com/150">싱글톤(singleton) 패턴</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-03T05:57:31.000Z" title="2020-02-03T05:57:31.000Z">2020-02-03</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">7분 읽기 (대략 983 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/03/javascript-module-pattern/">자바스크립트 모듈 패턴</a></h1><div class="content"><p>모듈이란 전제 어플리케이션의 일부를 독립된 코드로 분리하여 만들어 놓은 것이다.</p>
<h2 id="모듈화를-했을-때-장점"><a href="#모듈화를-했을-때-장점" class="headerlink" title="모듈화를 했을 때 장점"></a>모듈화를 했을 때 장점</h2><ul>
<li>자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 활용할 수 있다.</li>
<li>코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.</li>
<li>코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.</li>
<li>필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.</li>
<li>한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드할 때 시간과 네트워크 트래픽을 절약할 수 있다.(브라우저에서만 해당)</li>
</ul>
<p>자바스크립트에서 모듈을 구현하는 가장 쉬운 방법은 객체 리터럴을 사용하는 방법이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    key: <span class="string">'data'</span>,</span><br><span class="line">    publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.key); <span class="comment">// data</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.publicMethod()); <span class="comment">// data</span></span><br></pre></td></tr></table></figure>

<p>객체 리터럴은 모듈 패턴이기도 하며, 하나의 객체라는 점에서 싱글톤 패턴이라고도 할 수 있다. 동일한 코드를 어떠한 관점에서 보느냐에 따라 다양한 패턴이 될 수 있다. 객체 리터럴은 간단하지만 모든 속성이 공개되어있다는 단점이 있다. 독립된 모듈은 자체적으로 필요한 내부 변수 및 내부 함수를 모두 갖고 있어야 하므로 클로저를 이용해야 한다.</p>
<p>아래는 클로저를 이용한 모듈패턴이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * -----------------------</span></span><br><span class="line"><span class="comment">        * 모듈 패턴을 구현할 클로저 코드</span></span><br><span class="line"><span class="comment">        * -----------------------</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 은닉될 멤버 정의</span></span><br><span class="line">    <span class="keyword">var</span> privateKey = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateKey++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 공개될 멤버(특권 메소드) 정의</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicKey: privateKey,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.publicMethod()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.publicMethod()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>모듈 패턴의 반환값은 함수가 아닌 객체이다. 위의 코드를 순서대로 보면 익명함수가 자동으로 실행되고 반환된 객체를 module 변수에 할당한다. 따라서 module.publicMethod()처럼 메소드를 호출할 수 있다. 자동 호출되는점을 제외하고 클로저와 유사하다.</p>
<h3 id="클로저-경우"><a href="#클로저-경우" class="headerlink" title="클로저 경우"></a>클로저 경우</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> private = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        private++;</span><br><span class="line">        <span class="keyword">return</span> private;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> val = func();</span><br><span class="line"><span class="built_in">console</span>.log(val()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(val()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>그리고 인스턴스를 여러개 만들어 낼 수 있는 구조라는 점에서 싱글톤 패턴과 차이가 있다.</p>
<h3 id="싱글톤-패턴-경우"><a href="#싱글톤-패턴-경우" class="headerlink" title="싱글톤 패턴 경우"></a>싱글톤 패턴 경우</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> instance;</span><br><span class="line">    <span class="keyword">var</span> private = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            publicKey: private,</span><br><span class="line">            publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> publicKey;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 싱글톤 패턴은 아래 조건문에서 처음 인스턴스가 선언되면 다시 인스턴스를 만들지 않고 기존의 인스턴스를 리턴한다.</span></span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleton1 = singleton();</span><br><span class="line"><span class="keyword">var</span> singleton2 = singleton();</span><br><span class="line"><span class="built_in">console</span>.log(singleton1 === singleton2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>하나의 인스턴스를 선언하지 않고 여러개의 인스턴스를 생성하려면 익명함수를 사용하지 않고 생성자 함수 방식으로 만들면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> privateKey = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateKey++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicKey: privateKey,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = Module();</span><br><span class="line"><span class="built_in">console</span>.log(obj1.publicMethod()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.publicMethod()); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = Module();</span><br><span class="line"><span class="built_in">console</span>.log(obj2.publicMethod()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.publicMethod()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>위처럼 Module 함수를 정의하여 함수를 호출하면 여러개의 인스턴스를 생성할 수 있다. 클로저 인스턴스와 유사하지만, 한가지 차이점은 내부의 익명함수에서 반환값이 함수가 아니라 객체를 반환한다는 점이다.</p>
<p>모듈 패턴과 네임 스페이스 패턴을 함께 사용하면 더욱 깔끔한 코드가 완성된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = app || &#123;&#125;;</span><br><span class="line">app.module = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> privateKey = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateKey++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicKey: privateKey,</span><br><span class="line">        publicMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateMethod();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(app.module.publicMethod()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(app.module.publicMethod()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p><a href="https://webclub.tistory.com/5">module pattern (모듈패턴) #1</a><br><a href="https://asfirstalways.tistory.com/234">[JS_Design Pattern] 2. 모듈 패턴 (Module Pattern)</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-02-01T02:41:10.000Z" title="2020-02-01T02:41:10.000Z">2020-02-01</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">7분 읽기 (대략 1036 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/01/javascript-closure/">자바스크립트 클로저</a></h1><div class="content"><p>중첩함수에서 내부함수가 외부함수의 환경을 기억하는것을 클로저라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'data'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>func라는 함수를 선언하고 foo변수에 ‘data’문자열을 추가한 뒤 foo변수를 리턴하는 익명함수를 선언하였다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> closure = func();</span><br><span class="line"><span class="built_in">console</span>.log(closure());</span><br><span class="line"><span class="comment">// 'data'</span></span><br></pre></td></tr></table></figure>

<p>func함수의 리턴값을 closure변수에 할당한 뒤 closure를 실행한 값을 콘솔로 찍어보았다. 결과는 ‘data’라는 문자열이 출력되었다. func의 지역변수로 있는 foo는 func함수가 끝나면서 소멸되어야하지만 값을 잃지 않고 ‘data’값을 가지고 있다. 이 현상을 클로저라 한다. 다른 구문도 살펴보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closure = count();</span><br><span class="line"><span class="built_in">console</span>.log(closure());</span><br><span class="line"><span class="built_in">console</span>.log(closure());</span><br><span class="line"><span class="built_in">console</span>.log(closure());</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>count함수의 지역변수인 num값이 소멸되지 않고 계속 카운트되는 것을 확인해 볼 수 있다.</p>
<h2 id="은닉화"><a href="#은닉화" class="headerlink" title="은닉화"></a>은닉화</h2><p>자바스크립트에서는 인스턴스를 생성할때 Private Variables에 대한 접근 권한 문제가 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Create</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Create(<span class="string">'민수'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj._name);</span><br><span class="line"><span class="comment">// 민수</span></span><br></pre></td></tr></table></figure>

<p>위에서 생성된 obj객체의 _name프로퍼티는 변수명 앞에 _를 포함하였기 때문에 Private Variables로 쓰고싶다는 의도를 알 수 있다. 하지만 _name프로퍼티는 동적으로 변경될 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj._name = <span class="string">'인성'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj._name);</span><br><span class="line"><span class="comment">// 인성</span></span><br></pre></td></tr></table></figure>

<p>이 경우 클로저를 사용하여 외부에서 내부변수에 접근하는것을 제한할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _name = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hello = create(<span class="string">'민수'</span>);</span><br><span class="line">hello();</span><br><span class="line"><span class="comment">// 민수</span></span><br></pre></td></tr></table></figure>

<p>여기서는 외부에서 _name에 접근할 방법이 전혀 없다. 이렇게 클로저를 활용하여 은닉화를 해결할 수 있다.</p>
<h2 id="클로저는-고유한-환경을-가지고-있다"><a href="#클로저는-고유한-환경을-가지고-있다" class="headerlink" title="클로저는 고유한 환경을 가지고 있다."></a>클로저는 고유한 환경을 가지고 있다.</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> txt = name;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> txt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closure01 = func(<span class="string">'민수'</span>);</span><br><span class="line"><span class="keyword">var</span> closure02 = func(<span class="string">'인성'</span>);</span><br><span class="line"><span class="keyword">var</span> closure03 = func(<span class="string">'주영'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(closure01()); <span class="comment">// 민수</span></span><br><span class="line"><span class="built_in">console</span>.log(closure02()); <span class="comment">// 인성</span></span><br><span class="line"><span class="built_in">console</span>.log(closure03()); <span class="comment">// 주영</span></span><br></pre></td></tr></table></figure>

<p>위의 구문을 보면 txt변수가 동적으로 변화하는 것처럼 보이지만, 실제로는 txt변수 자체가 여러번 생성된 것이다. 즉, closure01(), closure02(), closure03()은 서로 다른 환경을 가지고 있다. 서로 다른 환경을 가지고 있다는것은 그만큼 메모리면에서 큰 비효율을 낳는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = input;</span><br><span class="line">    <span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.set = <span class="function"><span class="keyword">function</span> (<span class="params">rename</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = rename;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Func(<span class="string">'민수'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.get());</span><br></pre></td></tr></table></figure>

<p>위 코드는 생성자함수를 사용하여 인스턴스를 생성하는 구문인데, 클로저가 두번(get, set)이나 생성되었다. 이 상태에서 인스턴스를 계속 만들면 같은일을 하는 클로저가 중복으로 생성되고 메모리낭비가 심해질 것이다.<br>따라서 클로저는 객체의 prototype안에 저장함으로써 같은 기능을 모든 인스턴스가 공유하는 형태로 코드를 만들어야한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = input;</span><br><span class="line">&#125;</span><br><span class="line">Func.prototype.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">Func.prototype.set = <span class="function"><span class="keyword">function</span> (<span class="params">rename</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = rename;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Func(<span class="string">'민수'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.get());</span><br></pre></td></tr></table></figure>

<p>이렇게 prototype안에 클로저를 넣으면, 인스턴스가 생성되더라도 중복으로 메모리를 낭비하지 않고, 생성자 내부의 prototype안의 클로저를 참조하기 때문에 메모리낭비를 방지할 수 있다.</p>
<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>클로저는 독립적인(자유) 변수를 가리키는 함수 또는 클로저 안에 정의된 내부함수는 만들어진 환경을 기억한다.</li>
<li>클로저는 외부함수의 스코프 영역에 접근할 수 있고, 그것을 기억하고 있어야 한다.</li>
<li>외부함수가 종료된 후에도 내부함수는 외부함수를 계속 참조하고 있어야 한다.</li>
<li>데이터의 캡슐화 및 정보은닉에도 사용 가능하다.</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p><a href="https://hyunseob.github.io/2016/08/30/javascript-closure/">JavaScript 클로저(Closure)</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-18T01:10:16.000Z" title="2019-11-18T01:10:16.000Z">2019-11-18</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">몇 초 읽기 (대략 69 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/18/javascript-device-classification/">디바이스 구분 스크립트</a></h1><div class="content"><p>어떤 디바이스로 접속했는지 확인 가능한 코드</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filter = <span class="string">"win16|win32|win64|macintel|mac|"</span>; <span class="comment">// PC일 경우 가능한 값</span></span><br><span class="line"><span class="keyword">if</span>(navigator.platform)&#123;</span><br><span class="line">    <span class="keyword">if</span>(filter.indexOf(navigator.platform.toLowerCase()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        alert(<span class="string">"모바일에서 접속하셨습니다"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">"PC에서 접속하셨습니다"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-06-04T23:12:48.000Z" title="2019-06-04T23:12:48.000Z">2019-06-05</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">4분 읽기 (대략 546 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/05/javascript-block-scope/">var, let, const 차이</a></h1><div class="content"><p><code>var</code>는 변수를 선언하는 키워드이며, ES6부터 <code>let</code>과 <code>const</code>가 추가되었다.<br><code>var</code>는 함수 스코프를 가지고 <code>let</code>과 <code>const</code>는 블록 스코프를 가진다. 여기서 스코프란 코드가 실행되는 유효범휘이다.</p>
<h2 id="블록-스코프"><a href="#블록-스코프" class="headerlink" title="블록 스코프"></a>블록 스코프</h2><p>블록 스코프는 중괄호{}로 감싸진 범위를 말한다. 아래는 조건문(if), 반복문(for), 함수(function)가 블록 스코프를 가지고 있는 모습이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 블록 스코프</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 블록 스코프</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 블록 스코프</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>기존의 <code>var</code>는 위 세개중 함수에서만 스코프를 가진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: foo is not defined at window.onload</span></span><br></pre></td></tr></table></figure>

<p><code>var</code>는 중복 선언이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="let-const"><a href="#let-const" class="headerlink" title="let, const"></a>let, const</h2><p>ES6부터 추가된 <code>let</code>, <code>const</code>는 조건문과 반복문에도 스코프를 가진다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(B); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: a is not defined at window.onload</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: a is not defined at window.onload</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> d = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">console</span>.log(d); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// Uncaught ReferenceError: a is not defined at window.onload</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// Uncaught ReferenceError: a is not defined at window.onload</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> e = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">const</span> f = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(e); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">console</span>.log(f); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line"><span class="built_in">console</span>.log(e);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: foo is not defined at window.onload</span></span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: foo is not defined at window.onload</span></span><br></pre></td></tr></table></figure>

<p><code>let</code>과 <code>const</code>의 차이는 const 가 좀 더 엄격하다. <code>let</code>은 중복선언이 되지만 <code>const</code>는 중복선언이 안되기 때문에 변수가 선언될 때 값을 할당하여야 한다. <code>const</code>는 DB환경정보, API응답값 등 변하지 않을 값을 담을 때 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul>
<li><code>var</code>은 함수 스코프에서만 유효</li>
<li><code>let</code>, <code>const</code>는 블록 스코프에서 유효</li>
<li><code>const</code>는 선언과 동시에 할당이 일어나야하고, 재할당이 불가</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p><a href="https://yuddomack.tistory.com/entry/자바스크립트-변수와-스코프유효범위">자바스크립트 변수와 스코프(유효범위)</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-12-16T23:16:45.000Z" title="2018-12-16T23:16:45.000Z">2018-12-17</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">10분 읽기 (대략 1519 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/12/17/javascript-prototype/">프로토타입(Prototype)</a></h1><div class="content"><p>자바스크립트는 클래스라는 개념이 없다. 클래스는 자바, 파이썬, 루바 등 객체지향 언어에서 빠질수 없는 개념이다. 하지만 자바스크립트도 객체지향언어인데, 클래스 대신 프로토타입(Prototype)을 기반으로 클래스의 상속 기능을 흉내내도록 구현하여 사용한다. 그래서 자바스크립트는 프로토타입 기반의 객체 지향 언어라고 한다.</p>
<p>자바스크립트의 모든 객체는 자신의 부모역할을 담당하는 객체와 연결되어 있다. 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 프로토타입 이라 한다.</p>
<h2 id="프로토타입은-언제-쓰는가"><a href="#프로토타입은-언제-쓰는가" class="headerlink" title="프로토타입은 언제 쓰는가"></a>프로토타입은 언제 쓰는가</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eyes = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.nose = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kang = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> park = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(kang.eyes); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(kang.nose); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(park.eyes); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(park.nose); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>kang</code>과 <code>park</code>은 <code>eyes</code>와 <code>nose</code>를 공통적으로 가지고 있는데, 메모리는 <code>eyes</code>와 <code>nose</code>가 두개씩 총 4개에 할당된다. 객체를 100개를 만들면 200개의 변수가 메모리에 할당된다. 이런 메모리 낭비 문제를 프로토타입으로 해결할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.eyes = <span class="number">2</span>;</span><br><span class="line">Person.prototype.nose = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kang  = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> park = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(kang.eyes); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(park.nose); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>간략히 설명하면 <code>Person.prototype</code>라는 빈 객체가 어딘가에 존재하고 <code>Person</code>함수로부터 생성된 객체(<code>kang</code>, <code>park</code>)은 어딘가에 존재하는 객체의 값을 모두 갖다쓸 수 있다. 즉, <code>eyes</code>와 <code>nose</code>를 어딘가에 있는 빈 객체(<code>Person.prototype</code>)에 넣어두고, <code>kim</code>과 <code>park</code>이 공유해서 사용하는 것이다.</p>
<h2 id="프로토타입-객체와-프로토타입-링크"><a href="#프로토타입-객체와-프로토타입-링크" class="headerlink" title="프로토타입 객체와 프로토타입 링크"></a>프로토타입 객체와 프로토타입 링크</h2><p>자바스크립트에서는 프로토타입 객체(prototype object)와 프로토타입 링크(prototype link)라는 것이 존재한다. 그리고 이 둘을 통틀어 프로토타입이라고 부른다.</p>
<h3 id="객체는-언제나-함수로-생성된다"><a href="#객체는-언제나-함수로-생성된다" class="headerlink" title="객체는 언제나 함수로 생성된다."></a>객체는 언제나 함수로 생성된다.</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 함수</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(); <span class="comment">// new 키워드와 함수로 객체를 생성</span></span><br></pre></td></tr></table></figure>

<p>obj 객체는 <code>Person</code>이라는 함수로 생성된 객체이다. 일반적인 객체 리터럴 방식도 예외는 아니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>객체 리터럴 방식으로 객체를 생성하였는데 이 방식은 아래 방식과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p><code>Object</code>도 객체를 만드는 생성자 함수이다. <code>Object</code>와 마찬가지로 <code>Function, Array</code>도 모두 생성자 함수이다. 이 사실은 프로토타입과 밀접하게 관련이 있는데 함수가 정의될 때는 2가지 일이 동시에 일어나기 때문이다.</p>
<h2 id="함수가-정의될-때"><a href="#함수가-정의될-때" class="headerlink" title="함수가 정의될 때"></a>함수가 정의될 때</h2><h3 id="1-해당-함수에-constructor-생성자-자격-부여"><a href="#1-해당-함수에-constructor-생성자-자격-부여" class="headerlink" title="1. 해당 함수에 constructor(생성자) 자격 부여"></a>1. 해당 함수에 constructor(생성자) 자격 부여</h3><p>constructor 자격이 부여되면 new 키워드를 통해 객체를 만들수 있다. 오직 함수만 new 키워드를 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">// 객체 선언</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> obj();</span><br><span class="line"><span class="comment">// Uncaught TypeError: obj is not a constructor</span></span><br></pre></td></tr></table></figure>
<p><code>obj</code>는 생성자 자격이 없다고 나온다. 오직 함수만이 constructor 자격을 가질 수 있다.</p>
<h3 id="2-해당-함수의-프로토타입-객체-생성-및-연결"><a href="#2-해당-함수의-프로토타입-객체-생성-및-연결" class="headerlink" title="2. 해당 함수의 프로토타입 객체 생성 및 연결"></a>2. 해당 함수의 프로토타입 객체 생성 및 연결</h3><p>함수를 정의하면 함수만 생성되는 것이 아니라 프로토타입 객체도 같이 생성이 된다. 생성된 함수는 <code>prototype</code>라는 속성을 통해 프로토타입 객체에 접근할 수 있다. 프로토타입 객체는 일반적인 객체와 같으며, 기본적인 속성으로 <code>constructor</code>와 <code>__proto__</code>를 가지고 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">// &gt; constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">// &gt; __proto__: Object</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code>는 프로토타입 객체와 같이 생성되었던 함수를 가르키고 있다. <code>__proto__</code>은 프로토타입 링크다. 프로토타입 링크는 아래에서 다시 알아보도록 하고 위에서 언급된 <code>eyes, nose</code>예제를 다시 살펴보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.eyes = <span class="number">2</span>;</span><br><span class="line">Person.prototype.nose = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kang  = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> park = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype);</span><br><span class="line"><span class="comment">// &#123;eyes: 2, nose: 1, constructor: ƒ&#125;</span></span><br><span class="line"><span class="comment">// &gt; eyes: 2</span></span><br><span class="line"><span class="comment">// &gt; nose: 1</span></span><br><span class="line"><span class="comment">// &gt; constructor: ƒ Person()</span></span><br><span class="line"><span class="comment">// &gt; __proto__: Object</span></span><br></pre></td></tr></table></figure>

<p><code>Person.prototype</code>라는 빈 객체가 어딘가에 존재하고, 그 객체에 <code>eyes, nose</code>값을 할당한 것을 확인할 수 있다. 프로토타입 객체는 일반적인 객체이므로 속성을 마음대로 추가, 삭제할 수 있으며 <code>kang</code>과 <code>park</code>은 <code>Person</code>함수를 통해 생성되었으니 <code>Person.prototype</code>를 참조할 수 있게 된다.</p>
<h2 id="프로토타입-링크"><a href="#프로토타입-링크" class="headerlink" title="프로토타입 링크"></a>프로토타입 링크</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.eyes = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kang  = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(kang);</span><br><span class="line"><span class="comment">// Person &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(kang.eyes);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>kang</code>객체에 따로 <code>eyes</code>속성을 선언하지 않았지만 <code>kang.eyes</code>를 실행하면 <code>2</code>라는 값을 참조한다. 위에서 설명했듯이 프로토타입 객체의 <code>eyes</code>속성을 참조한 것인데, 이것이 가능한 이유는 <code>kang</code>이 가지고 있는 <code>__proto__</code>속성이 프로토타입 객체를 가르키고 있기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(kang.__proto__);</span><br><span class="line"><span class="comment">// &#123;eyes: 2, nose: 1, constructor: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>kang.__proto__</code> 속성을 확인해보니 프로토타입 객체를 가르키고 있다. <code>kang</code>객체는 직접 <code>eyes</code>속성을 가지고 있지 않아 <code>eyes</code>속성을 찾을 때 까지 상위 프로토타입을 탐색한다. 최상위인 <code>Object</code>의 프로토타입 객체까지 도달했는데도 못찾을 경우 <code>undefined</code>를 리턴한다. 이렇게 <code>__proto__</code>속성을 통해 상위 프로토타입과 연결되어있는 형태를 프로토타입 체인이라고 한다. 이런 프로토타입 체인 구조 때문에 모든 객체는 <code>Object</code>의 자식이라고 하며, <code>Object</code>에 있는 모드 속성을 사용할 수 있다.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p><a href="https://medium.com/@bluesh55/javascript-prototype-이해하기-f8e67c286b67">[Javascript ] 프로토타입 이해하기</a><br><a href="http://insanehong.kr/post/javascript-prototype">Javascript 기초 - Object prototype 이해하기</a><br><a href="http://www.nextree.co.kr/p7323">JavaScript : 프로토타입(prototype) 이해</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-11-07T23:11:18.000Z" title="2018-11-07T23:11:18.000Z">2018-11-08</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">5분 읽기 (대략 791 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/11/08/javascript-function-method/">함수 메소드(call, apply, bind)</a></h1><div class="content"><p>함수의 기본 메소드중 call, apply, bind 에 대해 알아보자</p>
<p>자바스크립트에서 상속개념을 자주 쓰다보면 불필요한 메소드에 프로토타입까지 상속받아 오기 때문에 메모리 낭비가 심해진다. 이때 다른 객체의 메소드를 가져와 쓸 수 있는데 그 기능을 가진 메소드가 call과 apply 이다. call 메소드 먼저 살펴보겠다.</p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func.call(obj, a, b);</span><br><span class="line">func &#x3D; 가져올 메소드</span><br><span class="line">call &#x3D; call 메소드</span><br><span class="line">obj &#x3D; 메소드를 사용할(현재) 객체</span><br><span class="line">a, b &#x3D; 메소드에 전달할 인자</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"obj1"</span>,</span><br><span class="line">    funcThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.funcThis()); <span class="comment">// Object &#123;name: "obj1"&#125;</span></span><br></pre></td></tr></table></figure>

<p>obj1 객체에 funcThis 메소드를 추가했다. funcThis 메소드는 자신을 감싼 obj1객체를 리턴하고 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"obj1"</span>,</span><br><span class="line">    funcThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">"obj2"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.funcThis.call(obj2)); <span class="comment">// Object &#123;name: "obj2"&#125;</span></span><br></pre></td></tr></table></figure>

<p>call 메소드를 이용하여 obj1 의 funcThis 메소드를 obj2 객체에서 실행한다. obj2객체를 리턴하고 있다. 아무 값을 안넣으면(null) window를 반환한다. call 과 형제격인 apply 메소드는 call 메소드와 같지만 한가지 다른점이 있다. call은 인자값을 하나 하나 전달하지만 apply 메소드는 인자값을 배열로 전달한다.</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func.apply(obj, [arr]);</span><br><span class="line">func &#x3D; 가져올 메소드</span><br><span class="line">apply &#x3D; apply 메소드</span><br><span class="line">obj &#x3D; 메소드를 사용할(현재) 객체</span><br><span class="line">arr &#x3D; 메소드에 전달할 인자 목록</span><br></pre></td></tr></table></figure>

<p>call 과 apply 는 보통 함수 내 arguments 객체와 같이 사용하는 모습을 많이 볼 수 있다. 처음에는 어려워 보이지만, 단순하게 보면 결국 arguments 객체에 다른 메소드를 빌려와 쓰는것으로 보면 된다. arguments 객체는 배열처럼 보이지만 실제 배열이 아닌 유사배열객체이기 때문에 배열 메소드가 없다(length 제외). 아래 구문은 arguments에 없는 배열의 메소드를 가져와 쓰는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">&#125;;</span><br><span class="line">func(<span class="string">"눈"</span>, <span class="string">"누"</span>, <span class="string">"난"</span>, <span class="string">"나"</span>); <span class="comment">// ["눈", "누"]</span></span><br></pre></td></tr></table></figure>

<p>위 함수를 보면 배열의 프로토타입에 있는 slice 메소드를 arguments 객체에서 사용하는 것을 알 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice 메소드 : 문자열의 일정 부분을 반환</span><br><span class="line">obj.slice(start, end);</span><br><span class="line">obj &#x3D; 필수. 반환할 배열 객체</span><br><span class="line">start &#x3D; 필수. 지정된 부분의 시작입</span><br><span class="line">start &#x3D; 선택. 지정된 부분의 끝</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.join.call(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;;</span><br><span class="line">func(<span class="string">"눈"</span>, <span class="string">"누"</span>, <span class="string">"난"</span>, <span class="string">"나"</span>); <span class="comment">// 눈-누-난-나</span></span><br></pre></td></tr></table></figure>

<p>join 메소드 : 인자값으로 넘겨진 구문을 모든 배열 요소에 추가한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.join(&quot;val&quot;);</span><br><span class="line">obj &#x3D; 필수. 반환할 배열 객체</span><br><span class="line">val &#x3D; 선택. 추가할 문자열 이다. 아무값도 안넣을 경우 쉼표(,)로 대체된다.</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind 함수는 함수가 가르키는 this만 바꾸고 호출은 하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">"obj1"</span>,</span><br><span class="line">    funcThis: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">"obj2"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = obj1.funcThis.bind(obj2);</span><br><span class="line">func(); <span class="comment">// Object &#123;name: "obj2"&#125;</span></span><br></pre></td></tr></table></figure>

<p>obj1 의 funcThis 메서드를 obj2 객체로 가져와서 func 변수에 할당했다. func 함수를 실행하면 obj2 객체가 출력된다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-11-02T13:04:56.000Z" title="2018-11-02T13:04:56.000Z">2018-11-02</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">3분 읽기 (대략 428 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/11/02/javascript-constructor-this/">생성자 함수에서의 This</a></h1><div class="content"><p>객체를 생성하는 방법은 크게 객체 리터널 방식과 생성자 함수 방식, Object() 생성자 함수 방식이 있다. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Func();</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>이 세가지 중 생성자 함수의 this를 알아보겠다.</p>
<p>생성자 함수는 기존 함수에 new 키워드를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. 일반 함수에서의 this는 window를 가르키지만 생성자 함수에서는 다르게 동작한다. 이때문에 원치 않은 상황이 나타날 수 있는데, 이를 피하기 위해 생성자 함수 이름의 첫 글자는 대문자로 작성하기를 권장하고 있다. </p>
<h2 id="일반-함수의-this"><a href="#일반-함수의-this" class="headerlink" title="일반 함수의 this"></a>일반 함수의 this</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line">func(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<h2 id="생성자-함수의-this"><a href="#생성자-함수의-this" class="headerlink" title="생성자 함수의 this"></a>생성자 함수의 this</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Func</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Func(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Func &#123;name: "foo"&#125;</span></span><br></pre></td></tr></table></figure>

<p>생성자 함수의 this 는 메서드 함수 호출과의 this 바인딩과 다르게 동한다. 이를 이해하려면 생성자 함수가 어떻게 동작하는지 알아야 한다. 위의 코드를 보면 </p>
<ol>
<li>생성자 함수가 정의되었고 인자값으로 name 프로퍼티의 값을 받고 있다. </li>
<li>new 키워드를 사용해서 생성자 함수를 호출하면 우선 빈 객체가 생성되고, 이 객체는 생성자 함수의 프로토타입을 참조한다.</li>
<li>생성자 함수가 실행되면서 동적으로 name 프로퍼티를 추가시킨다.</li>
<li>this로 바인딩한 객체가 생성자 함수의 리턴값으로 반환되서 obj 변수에 저장된다.</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-11-01T13:03:02.000Z" title="2018-11-01T13:03:02.000Z">2018-11-01</time><span class="level-item"><a class="link-muted" href="/categories/javascript/">javascript</a></span><span class="level-item">4분 읽기 (대략 633 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/11/01/javascript-this/">자바스크립트 This</a></h1><div class="content"><p>this는 함수가 호출되면 함수 내부로 암묵적으로 전달된다.<br>this는 메서드를 호출한 객체가 저장되어 있는 속성이다.<br>메서드 뿐만 아니라 일반 함수를 호출할때도 만들어 지며, 이벤트 리스너가 호출될 때에도 만들어진다. 문제는 this 속성에 저장되는 값이 동일한 값이 아니라 각각 다른점이다.</p>
<h2 id="this가-만들어지는-경우"><a href="#this가-만들어지는-경우" class="headerlink" title="this가 만들어지는 경우"></a>this가 만들어지는 경우</h2><ul>
<li>일반 함수에서의 this</li>
<li>중첩 함수에서의 this</li>
<li>이벤트 리스너에서의 this</li>
<li>메서드에서의 this</li>
<li>메서드 내부의 중첩 함수의 this</li>
</ul>
<h3 id="일반-함수에서의-this"><a href="#일반-함수에서의-this" class="headerlink" title="일반 함수에서의 this"></a>일반 함수에서의 this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>일반 함수 내부에서는 this는 전역객체인 window가 된다. 자바스크립트의 모든 전역 변수는 전역객체의 프로퍼티이다.</p>
<h3 id="중첩-함수에서의-this"><a href="#중첩-함수에서의-this" class="headerlink" title="중첩 함수에서의 this"></a>중첩 함수에서의 this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">    &#125;;</span><br><span class="line">    func2();</span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>

<p>일반 중첩 함수에서의 this 도 window 가 된다.</p>
<h3 id="이벤트-리스너에서의-this"><a href="#이벤트-리스너에서의-this" class="headerlink" title="이벤트 리스너에서의 this"></a>이벤트 리스너에서의 this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>이벤트 리스너에서의 this는 이벤트를 발생시킨 객체가 된다.</p>
<h3 id="메서드에서의-this"><a href="#메서드에서의-this" class="headerlink" title="메서드에서의 this"></a>메서드에서의 this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// object&#123;&#125;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.func();</span><br></pre></td></tr></table></figure>

<p>메서드에서의 this는 이벤트를 발생시킨 객체가 된다.</p>
<h3 id="메서드-내부의-중첩-함수의-this"><a href="#메서드-내부의-중첩-함수의-this" class="headerlink" title="메서드 내부의 중첩 함수의 this"></a>메서드 내부의 중첩 함수의 this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line">        &#125;;</span><br><span class="line">        func2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.func();</span><br></pre></td></tr></table></figure>

<p>메서드의 this 와는 다르게 window 를 가리킨다. 이는 내부 함수 호출 패턴을 정의해 놓지 않기 때문이다. 내부함수도 결국 함수이므로 이를 호출할 때는 함수 호출로 취급된다.<br>중첩함수가 메서드를 포함한 객체를 참조하려면 부모함수의 this를 내부함수가 접근 가능한 변수에 저장하면 된다.<br>보통 관례상 this 값을 저장하는 변수의 이름을 that 이라고 선언한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(that); <span class="comment">// window</span></span><br><span class="line">        &#125;;</span><br><span class="line">        func2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.func();</span><br></pre></td></tr></table></figure>

<p>자바스크립트는 위와 같은 바인딩의 한계를 극복하려고 this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공한다.<br>제이쿼리 등 자바스크립트 라이버리들의 경우 bind 라는 메서드를 통해, 사용자가 원하는 객체를 this에 바인딩 하는 기능을 제공하고 있다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-06-11T12:51:16.000Z" title="2018-06-11T12:51:16.000Z">2018-06-11</time><span class="level-item"><a class="link-muted" href="/categories/jquery/">jquery</a></span><span class="level-item">1분 읽기 (대략 128 단어)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/06/11/ios-scroll-off/">IOS 스크롤 방지</a></h1><div class="content"><p>모달 팝업에서 백그라운드 영역의 스크롤을 방지하고자 할 때 Android는 body에 <code>overflow: hidden</code> 속성만 줘도 스크롤이 방지되지만 IOS의 경우는 먹히지 않는다.<br>이럴 경우 body를 <code>position: fixed</code> 로 고정시킨 뒤 스크롤, 터치, 마우스 휠 이벤트를 막아버리면 된다.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scrollOff</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ios 스크롤 방지</span></span><br><span class="line">$(<span class="string">'body'</span>).addClass(<span class="string">'scrollOff'</span>).on(<span class="string">'scroll touchmove mousewheel'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ios 스크롤 방지</span></span><br><span class="line">$(<span class="string">'body'</span>).removeClass(<span class="string">'scrollOff'</span>).off(<span class="string">'scroll touchmove mousewheel'</span>);</span><br></pre></td></tr></table></figure>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/javascript/">이전</a></div><div class="pagination-next"><a href="/tags/javascript/page/3/">다음</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/javascript/">1</a></li><li><a class="pagination-link is-current" href="/tags/javascript/page/2/">2</a></li><li><a class="pagination-link" href="/tags/javascript/page/3/">3</a></li><li><a class="pagination-link" href="/tags/javascript/page/4/">4</a></li><li><a class="pagination-link" href="/tags/javascript/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/profile.gif" alt="기록맨"></figure><p class="title is-size-4 is-block line-height-inherit">기록맨</p><p class="is-size-6 is-block">FE Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>South Korea</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">포스트</p><a href="/archives"><p class="title">86</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">카테고리</p><a href="/categories"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">태그</p><a href="/tags"><p class="title">33</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">팔로우</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/recordboy"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">링크</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">카테고리</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/algorithm/"><span class="level-start"><span class="level-item">algorithm</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/centos/"><span class="level-start"><span class="level-item">centos</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/chrome/"><span class="level-start"><span class="level-item">chrome</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/github/"><span class="level-start"><span class="level-item">github</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/javascript/"><span class="level-start"><span class="level-item">javascript</span></span><span class="level-end"><span class="level-item tag">36</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/jquery/"><span class="level-start"><span class="level-item">jquery</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/mac/"><span class="level-start"><span class="level-item">mac</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/react/"><span class="level-start"><span class="level-item">react</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/sass/"><span class="level-start"><span class="level-item">sass</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/svelte-js/"><span class="level-start"><span class="level-item">svelte.js</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/ui/"><span class="level-start"><span class="level-item">ui</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue-js/"><span class="level-start"><span class="level-item">vue.js</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/web/"><span class="level-start"><span class="level-item">web</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">태그</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apache/"><span class="tag">apache</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos/"><span class="tag">centos</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cli/"><span class="tag">cli</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/command/"><span class="tag">command</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debug/"><span class="tag">debug</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es5/"><span class="tag">es5</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/es6/"><span class="tag">es6</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/github/"><span class="tag">github</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jQuery/"><span class="tag">jQuery</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/javascript/"><span class="tag">javascript</span><span class="tag is-grey-lightest">41</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jquery/"><span class="tag">jquery</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mac/"><span class="tag">mac</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node-js/"><span class="tag">node.js</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/php/"><span class="tag">php</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/react/"><span class="tag">react</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sass/"><span class="tag">sass</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/seo/"><span class="tag">seo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svelte-js/"><span class="tag">svelte.js</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/terminal/"><span class="tag">terminal</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ui/"><span class="tag">ui</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vanillaJs/"><span class="tag">vanillaJs</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vim/"><span class="tag">vim</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-js/"><span class="tag">vue.js</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web/"><span class="tag">web</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web-crawling/"><span class="tag">web crawling</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/youngcart5/"><span class="tag">youngcart5</span><span class="tag is-grey-lightest">2</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">최근 글</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-08T10:59:22.000Z">2020-03-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/08/react-props-state/">React Props, State</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/react/">react</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-07T10:57:39.000Z">2020-03-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/07/react-jsx/">React JSX</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/react/">react</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-06T10:55:52.000Z">2020-03-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/06/react-component/">React 초기 세팅 및 컴포넌트</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/react/">react</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-05T10:54:10.000Z">2020-03-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/05/react-introduce/">React 소개</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/react/">react</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-04T10:53:03.000Z">2020-03-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/04/javascript-es6-class/">ES6(ECMASrcipt 6) Class</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/javascript/">javascript</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">아카이브</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">3월 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">2월 2020</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">1월 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">12월 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">11월 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">10월 2019</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">8월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">7월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">6월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">5월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/04/"><span class="level-start"><span class="level-item">4월 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/03/"><span class="level-start"><span class="level-item">3월 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/12/"><span class="level-start"><span class="level-item">12월 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/11/"><span class="level-start"><span class="level-item">11월 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/06/"><span class="level-start"><span class="level-item">6월 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/05/"><span class="level-start"><span class="level-item">5월 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/03/"><span class="level-start"><span class="level-item">3월 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/02/"><span class="level-start"><span class="level-item">2월 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2018/01/"><span class="level-start"><span class="level-item">1월 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/12/"><span class="level-start"><span class="level-item">12월 2017</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/11/"><span class="level-start"><span class="level-item">11월 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/05/"><span class="level-start"><span class="level-item">5월 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2017/02/"><span class="level-start"><span class="level-item">2월 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="기록맨" height="28"></a><p class="size-small"><span>&copy; 2020 recordboy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("ko");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://recordboy.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Zurück nach oben" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="입력 하세요..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"입력 하세요...","untitled":"(Untitled)","posts":"포스트","pages":"Pages","categories":"카테고리","tags":"태그"});
        });</script></body></html>